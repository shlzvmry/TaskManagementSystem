This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .git, build, icons, database, *.user
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
dialogs/inspirationdialog.cpp
dialogs/inspirationdialog.h
dialogs/inspirationdialog.ui
dialogs/inspirationrecyclebindialog.cpp
dialogs/inspirationrecyclebindialog.h
dialogs/inspirationtagsearchdialog.cpp
dialogs/inspirationtagsearchdialog.h
dialogs/recyclebindialog.cpp
dialogs/recyclebindialog.h
dialogs/recyclebindialog.ui
dialogs/reminddialog.cpp
dialogs/reminddialog.h
dialogs/settingdialog.cpp
dialogs/settingdialog.h
dialogs/tagmanagerdialog.cpp
dialogs/tagmanagerdialog.h
dialogs/tagmanagerdialog.ui
dialogs/taskdialog.cpp
dialogs/taskdialog.h
dialogs/taskdialog.ui
main.cpp
mainwindow.cpp
mainwindow.h
models/inspirationmodel.cpp
models/inspirationmodel.h
models/statisticmodel.cpp
models/statisticmodel.h
models/taskfiltermodel.cpp
models/taskfiltermodel.h
models/taskitem.cpp
models/taskitem.h
models/taskmodel.cpp
models/taskmodel.h
resources/icons/add_icon.png
resources/icons/delete_icon.png
resources/icons/edit_icon.png
resources/icons/export_icon.png
resources/icons/left_arrow.png
resources/icons/recycle_icon.png
resources/icons/refresh_icon.png
resources/icons/right_arrow.png
resources/icons/tray_icon.png
resources/resources.qrc
resources/styles/calendar.qss
resources/styles/dialog.qss
resources/styles/kanban.qss
resources/styles/mainwindow.qss
resources/styles/statistic.qss
resources/styles/widget.qss
TaskManagementSystem.pro
threads/remindthread.cpp
threads/remindthread.h
utils/exporter.cpp
utils/exporter.h
views/calenderview.cpp
views/calenderview.h
views/inspirationview.cpp
views/inspirationview.h
views/kanbanview.cpp
views/kanbanview.h
views/statisticview.cpp
views/statisticview.h
views/tasktableview.cpp
views/tasktableview.h
widgets/comboboxdelegate.cpp
widgets/comboboxdelegate.h
widgets/prioritywidget.cpp
widgets/prioritywidget.h
widgets/simplechartwidget.cpp
widgets/simplechartwidget.h
widgets/statuswidget.cpp
widgets/statuswidget.h
widgets/tagwidget.cpp
widgets/tagwidget.h
widgets/watermarkwidget.cpp
widgets/watermarkwidget.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="resources/styles/mainwindow.qss">
/*主窗口全局样式 */
QMainWindow {
    background-color: #1e1e1e;
    color: #ffffff;
}

QWidget {
    background-color: #1e1e1e;
}

/* --- 标题栏 --- */
#titleLabel {
    color: #657896;
    font-size: 30px;
    font-weight: bold;
    padding: 10px;
    border-bottom: 2px solid #657896;
    margin-bottom: 10px;
}

/* --- Tab控件 --- */
#mainTabWidget {
    background-color: #2d2d2d;
    border: 1px solid #3d3d3d;
    border-radius: 5px;
    font-size: 16px;
}

#mainTabWidget::pane {
    background-color: #2d2d2d;
    border: 1px solid #3d3d3d;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
}

#mainTabWidget::tab-bar {
    alignment: center;
}

#mainTabWidget QTabBar::tab {
    background-color: #3d3d3d;
    color: #cccccc;
    padding: 8px 20px;
    margin-right: 2px;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    min-width: 100px;
}

#mainTabWidget QTabBar::tab:selected {
    background-color: #657896;
    color: #ffffff;
}

#mainTabWidget QTabBar::tab:hover:!selected {
    background-color: #4a5a6d;
    color: #ffffff;
}

/*  按钮样式 */
QPushButton {
    background-color: #657896;
    color: #ffffff;
    border: 1px solid #4d4d4d;
    border-radius: 4px;
    padding: 0px 16px;
    min-height: 36px;
    font-size: 14px;
    text-align: center;
}

QPushButton:hover {
    background-color: #4a5a6d;
    border-color: #657896;
}

QPushButton:pressed {
    background-color: #3a4a5d;
    border-color: #657896;
}

QPushButton:disabled {
    background-color: #2d2d2d;
    color: #666666;
    border-color: #3d3d3d;
}

QPushButton::menu-indicator {
    image: none;
}

QPushButton[objectName^="add"],
QPushButton[objectName^="edit"],
QPushButton[objectName^="delete"],
QPushButton[objectName^="refresh"],
QPushButton[objectName^="quickRecord"],
QPushButton[objectName^="listView"],
QPushButton[objectName^="kanbanView"],
QPushButton[objectName^="calendarView"] {
    qproperty-iconSize: 20px;
    padding-left: 15px;
    background-position: left 10px center;
    background-repeat: no-repeat;
    background-origin: content;
}

#listViewBtn, #kanbanViewBtn, #calendarViewBtn {
    padding: 8px 16px;
    min-height: 15px;
}

/* 标签与状态栏 */
#taskListLabel, #inspirationListLabel, #statisticLabel, #settingLabel {
    background-color: #2d2d2d;
    border: 2px dashed #3d3d3d;
    border-radius: 8px;
    color: #888888;
    font-size: 16px;
    padding: 20px;
    text-align: center;
}

QStatusBar {
    background-color: #2d2d2d;
    color: #cccccc;
    border-top: 1px solid #3d3d3d;
    font-size: 11px;
    padding: 2px 8px;
}

#infoLabel {
    color: #657896;
    font-size: 10px;
    font-style: italic;
    padding: 5px;
    border-top: 1px solid #3d3d3d;
}

/*  布局与输入控件  */
QHBoxLayout, QVBoxLayout {
    spacing: 8px;
    margin: 0;
    padding: 0;
}

QLabel {
    color: #cccccc;
    font-size: 12px;
}

QLineEdit, QTextEdit, QPlainTextEdit {
    background-color: #2d2d2d;
    color: #ffffff;
    border: 1px solid #3d3d3d;
    border-radius: 4px;
    padding: 0px 8px;
    selection-background-color: #657896;
    min-height: 36px;
}

QLineEdit:focus, QTextEdit:focus, QPlainTextEdit:focus {
    border: 2px solid #657896;
}

/* 组合框  */
QComboBox {
    background-color: #333333;
    color: #ffffff;
    border: 1px solid #555555;
    border-radius: 4px;
    padding: 0px 8px;
    min-height: 30px;
}

QComboBox:hover {
    border-color: #657896;
    background-color: #3d3d3d;
}

QComboBox:on {
    background-color: #3d3d3d;
}

QComboBox::drop-down {
    border: none;
    width: 20px;
    background-color: transparent;
}

QComboBox::down-arrow {
    width: 12px;
    height: 12px;
}

QComboBox#filterCategoryCombo,
QComboBox#filterPriorityCombo {
    background-color: #2d2d2d;
    color: #ffffff;
    border: 1px solid #3d3d3d;
    border-radius: 4px;
    padding: 0px 8px;
    min-height: 30px;
}

QComboBox#filterCategoryCombo:hover,
QComboBox#filterPriorityCombo:hover {
    border: 1px solid #657896;
    background-color: #3d3d3d;
}

QComboBox#filterCategoryCombo QAbstractItemView,
QComboBox#filterPriorityCombo QAbstractItemView {
    background-color: #2d2d2d;
    color: #ffffff;
    selection-background-color: #657896;
    selection-color: #ffffff;
    border: 1px solid #3d3d3d;
    outline: none;
}

/* 复选框与单选框 */
QCheckBox {
    color: #cccccc;
    spacing: 8px;
}

QCheckBox::indicator {
    width: 16px;
    height: 16px;
    border: 1px solid #3d3d3d;
    border-radius: 3px;
    background-color: #2d2d2d;
}

QCheckBox::indicator:checked {
    background-color: #657896;
    border-color: #657896;
    image: url(:/icons/checkmark.png);
}

QRadioButton {
    color: #cccccc;
    spacing: 8px;
}

QRadioButton::indicator {
    width: 16px;
    height: 16px;
    border: 1px solid #3d3d3d;
    border-radius: 8px;
    background-color: #2d2d2d;
}

QRadioButton::indicator:checked {
    background-color: #657896;
    border-color: #657896;
}

/* 分体式表头设计 */

/* 1. 已完成任务分隔条 */
#completedSeparatorBtn {
    background-color: #455266;
    border: none;
    border-radius: 0px;
    min-height: 7px;
    max-height: 7px;
    height: 7px;
    margin: 0px;
    padding: 0px;
}

#completedSeparatorBtn:hover {
    background-color: #4F5E75;
}

/* 2. 通用表头样式 */
QHeaderView::section {
    background-color: #455266;
    color: white;
    padding: 1px;
    border: none;
    border-right: 1px solid #2d2d2d;
    border-bottom: 1px solid #2d2d2d;
    font-size: 13px;
    font-weight: bold;
    min-height: 29px;
}

QHeaderView::section:hover {
    background-color: #4F5E75;
}

/* 3. 已完成任务表头 */
#completedTableView QHeaderView::section {
    background-color: #455266;
    padding-top: -2px;
    padding-bottom: 4px;
    min-height: 22px;
    max-height: 22px;
    border-top: none;
}

#completedTableView QHeaderView::section:hover {
    background-color: #4F5E75;
}

/*灵感视图*/
QComboBox#filterTagCombo {
    background-color: #2d2d2d;
    color: #ffffff;
    border: 1px solid #3d3d3d;
    border-radius: 4px;
    padding: 2px 8px;
    min-height: 28px;
}

QComboBox#filterTagCombo:hover {
    border: 1px solid #657896;
    background-color: #3d3d3d;
}

QComboBox#filterTagCombo::drop-down {
    border: none;
    width: 20px;
}

QComboBox#filterTagCombo QAbstractItemView {
    background-color: #2d2d2d;
    color: #ffffff;
    selection-background-color: #657896;
    border: 1px solid #3d3d3d;
}

/* --- 系统托盘菜单样式 --- */
QMenu {
    background-color: #657896;
    border: 1px solid #4d4d4d;
    padding: 4px;
    border-radius: 6px;
    color: #ffffff; /* 文字保持白色 */
}

QMenu::item {
    background-color: transparent;
    padding: 6px 24px 6px 10px;
    border-radius: 4px;
    margin: 2px 0px;
}

QMenu::item:selected {
    background-color: #4a5a6d;
    color: #ffffff;
}

QMenu::item:disabled {
    color: #cccccc;
}

QMenu::separator {
    height: 1px;
    background: #4d4d4d;
    margin: 4px 10px;
}

QMenu::icon {
    padding-left: 10px;
}
</file>

<file path="resources/styles/widget.qss">
/* 优先级控件样式 */
PriorityWidget QPushButton {
    color: white;
    border: 2px solid transparent;
    border-radius: 4px;
    font-size: 12px;
    font-weight: normal;
    padding: 0px;
    margin: 0px;
    background-color: #4C566A;
    min-height: 24px;
    max-height: 26px;
}

PriorityWidget QPushButton:checked {
    border-color: rgba(255, 255, 255, 0.6);
    font-weight: bold;
}

PriorityWidget QPushButton#priorityBtn_0 { background-color: #C96A6A; }
PriorityWidget QPushButton#priorityBtn_0:hover { background-color: #D47C7C; }
PriorityWidget QPushButton#priorityBtn_0:checked { background-color: #B05555; }

PriorityWidget QPushButton#priorityBtn_1 { background-color: #D69E68; }
PriorityWidget QPushButton#priorityBtn_1:hover { background-color: #E0AB79; }
PriorityWidget QPushButton#priorityBtn_1:checked { background-color: #BF8855; }

PriorityWidget QPushButton#priorityBtn_2 { background-color: #7FA882; }
PriorityWidget QPushButton#priorityBtn_2:hover { background-color: #91B693; }
PriorityWidget QPushButton#priorityBtn_2:checked { background-color: #6D9470; }

PriorityWidget QPushButton#priorityBtn_3 { background-color: #8C949E; }
PriorityWidget QPushButton#priorityBtn_3:hover { background-color: #9DA5AE; }
PriorityWidget QPushButton#priorityBtn_3:checked { background-color: #707882; }


/* 状态控件样式 */
StatusWidget QPushButton {
    color: white;
    border: 2px solid transparent;
    border-radius: 4px;
    font-size: 12px;
    font-weight: normal;
    padding: 0px;
    background-color: #4C566A;
    min-height: 24px;
    max-height: 26px;
}

StatusWidget QPushButton:checked {
    border-color: rgba(255, 255, 255, 0.6);
    font-weight: bold;
}

StatusWidget QPushButton#statusBtn_0 { background-color: #7696B3; }
StatusWidget QPushButton#statusBtn_0:hover { background-color: #87A5BF; }
StatusWidget QPushButton#statusBtn_0:checked { background-color: #62829E; }

StatusWidget QPushButton#statusBtn_1 { background-color: #D69E68; }
StatusWidget QPushButton#statusBtn_1:hover { background-color: #E0AB79; }
StatusWidget QPushButton#statusBtn_1:checked { background-color: #BF8855; }

StatusWidget QPushButton#statusBtn_2 { background-color: #7FA882; }
StatusWidget QPushButton#statusBtn_2:hover { background-color: #91B693; }
StatusWidget QPushButton#statusBtn_2:checked { background-color: #6D9470; }

StatusWidget QPushButton#statusBtn_3 { background-color: #C96A6A; }
StatusWidget QPushButton#statusBtn_3:hover { background-color: #D47C7C; }
StatusWidget QPushButton#statusBtn_3:checked { background-color: #B05555; }

/* 标签控件样式 */
TagWidget QPushButton {
    color: white;
    border: none;
    border-radius: 12px;
    padding: 2px 10px;
    font-size: 11px;
    font-weight: normal;
    min-height: 20px;
}

QTableView QComboBox {
    background-color: #2d2d2d;
    color: white;
    border: none;
    padding: 0px 4px;

    min-height: 24px;
    max-height: 24px;
}

QTableView QComboBox::drop-down {
    border: none;
    width: 20px;
}

QTableView QComboBox QAbstractItemView {
    background-color: #2d2d2d;
    color: white;
    selection-background-color: #657896;
    outline: none;
    border: 1px solid #3d3d3d;
}
</file>

<file path=".gitignore">
# This file is used to ignore files which are generated
# ----------------------------------------------------------------------------

*~
*.autosave
*.a
*.core
*.moc
*.o
*.obj
*.orig
*.rej
*.so
*.so.*
*_pch.h.cpp
*_resource.rc
*.qm
.#*
*.*#
core
!core/
tags
.DS_Store
.directory
*.debug
Makefile*
*.prl
*.app
moc_*.cpp
ui_*.h
qrc_*.cpp
Thumbs.db
*.res
*.rc
/.qmake.cache
/.qmake.stash

# qtcreator generated files
*.pro.user*
*.qbs.user*
CMakeLists.txt.user*

# xemacs temporary files
*.flc

# Vim temporary files
.*.swp

# Visual Studio generated files
*.ib_pdb_index
*.idb
*.ilk
*.pdb
*.sln
*.suo
*.vcproj
*vcproj.*.*.user
*.ncb
*.sdf
*.opensdf
*.vcxproj
*vcxproj.*

# MinGW generated files
*.Debug
*.Release

# Python byte code
*.pyc

# Binaries
# --------
*.dll
*.exe

# Directories with generated files
.moc/
.obj/
.pch/
.rcc/
.uic/
/build*/
</file>

<file path="dialogs/inspirationdialog.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
 </widget>
 <resources/>
 <connections/>
</ui>
</file>

<file path="dialogs/inspirationrecyclebindialog.cpp">
#include "inspirationrecyclebindialog.h"
#include "models/inspirationmodel.h"

InspirationRecycleBinDialog::InspirationRecycleBinDialog(InspirationModel *model, QWidget *parent)
    : QDialog(parent), m_model(model)
{
    setWindowTitle("灵感回收站");
    resize(760, 400);
    setupUI();
    refresh();
}

void InspirationRecycleBinDialog::setupUI()
{
    QVBoxLayout *layout = new QVBoxLayout(this);

    QHBoxLayout *topLayout = new QHBoxLayout();
    m_statusLabel = new QLabel("共 0 条记录", this);
    topLayout->addWidget(m_statusLabel);
    topLayout->addStretch();

    QPushButton *emptyBtn = new QPushButton("清空回收站", this);
    emptyBtn->setIcon(QIcon(":/icons/delete_icon.png"));
    connect(emptyBtn, &QPushButton::clicked, this, &InspirationRecycleBinDialog::onEmpty);
    topLayout->addWidget(emptyBtn);
    layout->addLayout(topLayout);

    m_table = new QTableWidget(this);
    m_table->setColumnCount(4);

    m_table->setHorizontalHeaderLabels({"记录时间", "内容预览", "标签", "删除时间"});

    QHeaderView *header = m_table->horizontalHeader();
    header->setSectionResizeMode(QHeaderView::Interactive);
    header->setStretchLastSection(true);

    m_table->setColumnWidth(0, 140);
    m_table->setColumnWidth(1, 340);
    m_table->setColumnWidth(2, 120);

    m_table->verticalHeader()->hide();
    m_table->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_table->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_table->setAlternatingRowColors(true);
    layout->addWidget(m_table);

    QHBoxLayout *btnLayout = new QHBoxLayout();
    QPushButton *restoreBtn = new QPushButton("恢复选中", this);
    QPushButton *deleteBtn = new QPushButton("永久删除", this);
    QPushButton *closeBtn = new QPushButton("关闭", this);

    connect(restoreBtn, &QPushButton::clicked, this, &InspirationRecycleBinDialog::onRestore);
    connect(deleteBtn, &QPushButton::clicked, this, &InspirationRecycleBinDialog::onDelete);
    connect(closeBtn, &QPushButton::clicked, this, &QDialog::accept);

    btnLayout->addStretch();
    btnLayout->addWidget(restoreBtn);
    btnLayout->addWidget(deleteBtn);
    btnLayout->addWidget(closeBtn);
    layout->addLayout(btnLayout);
}

void InspirationRecycleBinDialog::refresh()
{
    m_table->setRowCount(0);
    QList<QVariantMap> list = m_model->getDeletedInspirations();
    m_statusLabel->setText(QString("共 %1 条已删除记录").arg(list.size()));

    for(const QVariantMap &data : list) {
        int row = m_table->rowCount();
        m_table->insertRow(row);

        QDateTime createTime = data["created_at"].toDateTime();
        QTableWidgetItem *timeItem = new QTableWidgetItem(createTime.toString("yyyy-MM-dd HH:mm"));
        timeItem->setData(Qt::UserRole, data["id"]);
        timeItem->setTextAlignment(Qt::AlignCenter);
        m_table->setItem(row, 0, timeItem);

        QTableWidgetItem *contentItem = new QTableWidgetItem(data["content"].toString());
        contentItem->setTextAlignment(Qt::AlignLeft | Qt::AlignVCenter);
        contentItem->setToolTip(data["content"].toString());
        m_table->setItem(row, 1, contentItem);

        QTableWidgetItem *tagItem = new QTableWidgetItem(data["tags"].toString());
        tagItem->setTextAlignment(Qt::AlignCenter);
        tagItem->setToolTip(data["tags"].toString());
        m_table->setItem(row, 2, tagItem);

        QDateTime deleteTime = data["updated_at"].toDateTime();
        QTableWidgetItem *delTimeItem = new QTableWidgetItem(deleteTime.toString("yyyy-MM-dd HH:mm"));
        delTimeItem->setTextAlignment(Qt::AlignCenter);
        m_table->setItem(row, 3, delTimeItem);
    }
}

void InspirationRecycleBinDialog::onRestore()
{
    int row = m_table->currentRow();
    if (row < 0) return;
    int id = m_table->item(row, 0)->data(Qt::UserRole).toInt();

    if (m_model->restoreInspiration(id)) {
        refresh();
    }
}

void InspirationRecycleBinDialog::onDelete()
{
    int row = m_table->currentRow();
    if (row < 0) return;
    int id = m_table->item(row, 0)->data(Qt::UserRole).toInt();

    if (QMessageBox::question(this, "确认", "确定要永久删除吗？此操作不可恢复。") == QMessageBox::Yes) {
        if (m_model->permanentDeleteInspiration(id)) {
            refresh();
        }
    }
}

void InspirationRecycleBinDialog::onEmpty()
{
    if (QMessageBox::question(this, "确认", "确定要清空回收站吗？") == QMessageBox::Yes) {
        m_model->emptyRecycleBin();
        refresh();
    }
}
</file>

<file path="dialogs/inspirationrecyclebindialog.h">
#ifndef INSPIRATIONRECYCLEBINDIALOG_H
#define INSPIRATIONRECYCLEBINDIALOG_H

#include <QDialog>
#include <QTableWidget>
#include <QPushButton>
#include <QLabel>
#include <QVBoxLayout>
#include <QHeaderView>
#include <QMessageBox>

class InspirationModel;

class InspirationRecycleBinDialog : public QDialog
{
    Q_OBJECT
public:
    explicit InspirationRecycleBinDialog(InspirationModel *model, QWidget *parent = nullptr);

private slots:
    void refresh();
    void onRestore();
    void onDelete();
    void onEmpty();

private:
    InspirationModel *m_model;
    QTableWidget *m_table;
    QLabel *m_statusLabel;

    void setupUI();
};

#endif // INSPIRATIONRECYCLEBINDIALOG_H
</file>

<file path="dialogs/inspirationtagsearchdialog.cpp">
#include "inspirationtagsearchdialog.h"
#include "models/inspirationmodel.h"
#include "widgets/tagwidget.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLineEdit>
#include <QLabel>
#include <QPushButton>
#include <QScrollArea>
#include <QCheckBox>
#include <QDialogButtonBox>
#include <QStyle>
#include <QLayout>
#include <QDebug>

class FlowLayout : public QLayout
{
public:
    explicit FlowLayout(QWidget *parent, int margin = -1, int hSpacing = -1, int vSpacing = -1)
        : QLayout(parent), m_hSpace(hSpacing), m_vSpace(vSpacing)
    {
        setContentsMargins(margin, margin, margin, margin);
    }

    ~FlowLayout() {
        QLayoutItem *item;
        while ((item = takeAt(0))) delete item;
    }

    void addItem(QLayoutItem *item) override { itemList.append(item); }
    int horizontalSpacing() const { return m_hSpace >= 0 ? m_hSpace : smartSpacing(QStyle::PM_LayoutHorizontalSpacing); }
    int verticalSpacing() const { return m_vSpace >= 0 ? m_vSpace : smartSpacing(QStyle::PM_LayoutVerticalSpacing); }
    int count() const override { return itemList.size(); }
    QLayoutItem *itemAt(int index) const override { return itemList.value(index); }
    QLayoutItem *takeAt(int index) override {
        if (index >= 0 && index < itemList.size()) return itemList.takeAt(index);
        return nullptr;
    }

    Qt::Orientations expandingDirections() const override { return Qt::Orientation(0); }
    bool hasHeightForWidth() const override { return true; }
    int heightForWidth(int width) const override { return doLayout(QRect(0, 0, width, 0), true); }
    void setGeometry(const QRect &rect) override {
        QLayout::setGeometry(rect);
        doLayout(rect, false);
    }
    QSize sizeHint() const override { return minimumSize(); }
    QSize minimumSize() const override {
        QSize size;
        for (const QLayoutItem *item : itemList)
            size = size.expandedTo(item->minimumSize());
        QMargins margins = contentsMargins();
        size += QSize(margins.left() + margins.right(),
            margins.top() + margins.bottom());
        return size;
    }

private:
    int doLayout(const QRect &rect, bool testOnly) const {
        int left, top, right, bottom;
        getContentsMargins(&left, &top, &right, &bottom);
        QRect effectiveRect = rect.adjusted(+left, +top, -right, -bottom);
        int x = effectiveRect.x();
        int y = effectiveRect.y();
        int lineHeight = 0;

        for (QLayoutItem *item : itemList) {
            QWidget *wid = item->widget();
            int spaceX = horizontalSpacing();
            if (spaceX == -1) spaceX = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
            int spaceY = verticalSpacing();
            if (spaceY == -1) spaceY = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);

            int nextX = x + item->sizeHint().width() + spaceX;
            if (nextX - spaceX > effectiveRect.right() && lineHeight > 0) {
                x = effectiveRect.x();
                y = y + lineHeight + spaceY;
                nextX = x + item->sizeHint().width() + spaceX;
                lineHeight = 0;
            }

            if (!testOnly) item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));

            x = nextX;
            lineHeight = qMax(lineHeight, item->sizeHint().height());
        }
        return y + lineHeight - rect.y() + bottom;
    }
    int smartSpacing(QStyle::PixelMetric pm) const {
        QObject *parent = this->parent();
        if (!parent) return -1;
        else if (parent->isWidgetType()) {
            QWidget *pw = static_cast<QWidget *>(parent);
            return pw->style()->pixelMetric(pm, nullptr, pw);
        }
        return -1;
    }

    QList<QLayoutItem *> itemList;
    int m_hSpace;
    int m_vSpace;
};

InspirationTagSearchDialog::InspirationTagSearchDialog(InspirationModel *model, const QStringList &initialSelection, QWidget *parent)
    : QDialog(parent), m_model(model), m_selectedTags(initialSelection)
{
    setWindowTitle("标签检索");
    resize(500, 400);
    setupUI();
    loadTags();
}

void InspirationTagSearchDialog::setupUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);

    QHBoxLayout *searchLayout = new QHBoxLayout();
    m_searchEdit = new QLineEdit(this);
    m_searchEdit->setPlaceholderText("搜索标签...");
    connect(m_searchEdit, &QLineEdit::textChanged, this, &InspirationTagSearchDialog::onSearchTextChanged);
    searchLayout->addWidget(m_searchEdit);
    mainLayout->addLayout(searchLayout);

    m_scrollArea = new QScrollArea(this);
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setFrameShape(QFrame::NoFrame);

    m_containerWidget = new QWidget();
    FlowLayout *flowLayout = new FlowLayout(m_containerWidget, 10, 8, 8);
    m_containerWidget->setLayout(flowLayout);

    m_scrollArea->setWidget(m_containerWidget);
    mainLayout->addWidget(m_scrollArea);

    QHBoxLayout *bottomLayout = new QHBoxLayout();

    m_matchAllCheckBox = new QCheckBox("仅显示包含所有选中标签的记录", this);
    bottomLayout->addWidget(m_matchAllCheckBox);
    bottomLayout->addStretch();

    QPushButton *cancelBtn = new QPushButton("取消", this);
    QPushButton *okBtn = new QPushButton("确定", this);
    okBtn->setDefault(true);

    connect(cancelBtn, &QPushButton::clicked, this, &QDialog::reject);
    connect(okBtn, &QPushButton::clicked, this, &InspirationTagSearchDialog::onConfirm);

    bottomLayout->addWidget(cancelBtn);
    bottomLayout->addWidget(okBtn);
    mainLayout->addLayout(bottomLayout);
}

void InspirationTagSearchDialog::loadTags()
{
    m_allTags = m_model->getAllTags();
    m_allTags.sort();
    refreshTagGrid();
}

void InspirationTagSearchDialog::refreshTagGrid()
{
    QLayout *layout = m_containerWidget->layout();
    QLayoutItem *item;
    while ((item = layout->takeAt(0)) != nullptr) {
        if (item->widget()) delete item->widget();
        delete item;
    }
    m_tagButtons.clear();

    QString filter = m_searchEdit->text().trimmed();

    if (filter.isEmpty()) {
        m_allBtn = new QPushButton("All/清空", m_containerWidget);
        m_allBtn->setObjectName("tagSearchAllBtn");
        m_allBtn->setCheckable(true);
        m_allBtn->setFixedHeight(26);
        m_allBtn->setCursor(Qt::PointingHandCursor);

        m_allBtn->setChecked(m_selectedTags.isEmpty());
        connect(m_allBtn, &QPushButton::clicked, this, &InspirationTagSearchDialog::onAllButtonClicked);
        layout->addWidget(m_allBtn);
    }

    for (const QString &tag : m_allTags) {
        if (!filter.isEmpty() && !tag.contains(filter, Qt::CaseInsensitive)) {
            continue;
        }

        QPushButton *btn = new QPushButton(tag, m_containerWidget);
        btn->setProperty("class", "tagSearchBtn");
        btn->setCheckable(true);
        btn->setFixedHeight(26);
        btn->setCursor(Qt::PointingHandCursor);

        QString color = TagWidget::generateColor(tag);
        QString dynamicStyle = QString(
                                   "QPushButton { color: #ccc; border: 1px solid %1; }"
                                   "QPushButton:checked { background-color: %1; color: white; border: 1px solid %1; }"
                                   "QPushButton:hover { border: 2px solid %1; }"
                                   ).arg(color);
        btn->setStyleSheet(dynamicStyle);

        if (m_selectedTags.contains(tag)) {
            btn->setChecked(true);
        }

        connect(btn, &QPushButton::clicked, this, &InspirationTagSearchDialog::onTagButtonClicked);
        m_tagButtons.append(btn);

        layout->addWidget(btn);
    }
}

void InspirationTagSearchDialog::onSearchTextChanged(const QString &text)
{
    Q_UNUSED(text);
    refreshTagGrid();
}

void InspirationTagSearchDialog::onTagButtonClicked()
{
    QPushButton *senderBtn = qobject_cast<QPushButton*>(sender());
    if (!senderBtn) return;

    if (senderBtn->isChecked()) {
        if (m_allBtn) m_allBtn->setChecked(false);
    } else {
        bool hasChecked = false;
        for (QPushButton *btn : m_tagButtons) {
            if (btn->isChecked()) {
                hasChecked = true;
                break;
            }
        }
        if (!hasChecked && m_allBtn) m_allBtn->setChecked(true);
    }
}

void InspirationTagSearchDialog::onAllButtonClicked()
{
    if (m_allBtn->isChecked()) {
        for (QPushButton *btn : m_tagButtons) {
            btn->setChecked(false);
        }
    } else {
        m_allBtn->setChecked(true);
    }
}

void InspirationTagSearchDialog::onConfirm()
{
    m_selectedTags.clear();
    for (QPushButton *btn : m_tagButtons) {
        if (btn->isChecked()) {
            m_selectedTags.append(btn->text());
        }
    }
    accept();
}

QStringList InspirationTagSearchDialog::getSelectedTags() const
{
    return m_selectedTags;
}

bool InspirationTagSearchDialog::isMatchAll() const
{
    return m_matchAllCheckBox->isChecked();
}
</file>

<file path="dialogs/inspirationtagsearchdialog.h">
#ifndef INSPIRATIONTAGSEARCHDIALOG_H
#define INSPIRATIONTAGSEARCHDIALOG_H

#include <QDialog>
#include <QList>
#include <QStringList>

class QLineEdit;
class QCheckBox;
class QScrollArea;
class QPushButton;
class InspirationModel;

class InspirationTagSearchDialog : public QDialog
{
    Q_OBJECT

public:
    explicit InspirationTagSearchDialog(InspirationModel *model, const QStringList &initialSelection, QWidget *parent = nullptr);

    QStringList getSelectedTags() const;
    bool isMatchAll() const;

private slots:
    void onSearchTextChanged(const QString &text);
    void onTagButtonClicked();
    void onAllButtonClicked();
    void onConfirm();

private:
    InspirationModel *m_model;
    QLineEdit *m_searchEdit;
    QScrollArea *m_scrollArea;
    QWidget *m_containerWidget;
    QCheckBox *m_matchAllCheckBox;
    QPushButton *m_allBtn;

    QList<QPushButton*> m_tagButtons;
    QStringList m_selectedTags;
    QStringList m_allTags;

    void setupUI();
    void loadTags();
    void refreshTagGrid();
    void updateAllButtonState();
};

#endif // INSPIRATIONTAGSEARCHDIALOG_H
</file>

<file path="dialogs/recyclebindialog.h">
#ifndef RECYCLEBINDIALOG_H
#define RECYCLEBINDIALOG_H

#include <QDialog>
#include <QList>
#include <QVariantMap>

namespace Ui {
class RecycleBinDialog;
}

class TaskModel;

class RecycleBinDialog : public QDialog
{
    Q_OBJECT

public:
    explicit RecycleBinDialog(QWidget *parent = nullptr);
    ~RecycleBinDialog();

    void setTaskModel(TaskModel *model);
    void refreshDeletedTasks();

private slots:
    void onRestoreClicked();
    void onDeletePermanentlyClicked();
    void onClearAllClicked();
    void onRefreshClicked();
    void onCloseClicked();
    void updateButtonStates();

private:
    Ui::RecycleBinDialog *ui;
    TaskModel *taskModel;
    QList<QVariantMap> deletedTasks;

    void setupUI();
    void setupConnections();
    void setupTable();
    int getSelectedTaskId() const;
    void showConfirmationDialog(const QString &title, const QString &message,
                                std::function<void()> onConfirmed);
};

#endif // RECYCLEBINDIALOG_H
</file>

<file path="dialogs/recyclebindialog.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>RecycleBinDialog</class>
 <widget class="QDialog" name="RecycleBinDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1000</width>  <!-- 增加宽度 -->
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>回收站</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="titleLabel">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:14pt; font-weight:600; color:#657896;&quot;&gt;回收站管理&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QFrame" name="frame">
     <property name="frameShape">
      <enum>QFrame::Shape::StyledPanel</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Shadow::Raised</enum>
     </property>
     <layout class="QHBoxLayout" name="horizontalLayout">
      <item>
       <widget class="QLabel" name="statusLabel">
        <property name="text">
         <string>共 0 个已删除任务</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer">
        <property name="orientation">
         <enum>Qt::Orientation::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="restoreButton">
        <property name="enabled">
         <bool>false</bool>
        </property>
        <property name="text">
         <string>恢复选中</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="deletePermanentlyButton">
        <property name="enabled">
         <bool>false</bool>
        </property>
        <property name="text">
         <string>永久删除</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="clearAllButton">
        <property name="enabled">
         <bool>false</bool>
        </property>
        <property name="text">
         <string>清空回收站</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="refreshButton">
        <property name="text">
         <string>刷新</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="closeButton">
        <property name="text">
         <string>关闭</string>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QTableWidget" name="tableWidget">
     <property name="columnCount">
      <number>7</number>
     </property>
     <property name="rowCount">
      <number>0</number>
     </property>
     <property name="alternatingRowColors">
      <bool>true</bool>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectionBehavior::SelectRows</enum>
     </property>
     <property name="showGrid">
      <bool>true</bool>
     </property>
     <property name="gridStyle">
      <enum>Qt::PenStyle::SolidLine</enum>
     </property>
     <property name="sortingEnabled">
      <bool>false</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <property name="cornerButtonEnabled">
      <bool>true</bool>
     </property>
     <attribute name="horizontalHeaderHighlightSections">
      <bool>false</bool>
     </attribute>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>false</bool>  <!-- 改为false，不要拉伸最后一列 -->
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="horizontalHeaderCascadingSectionResizes">
      <bool>false</bool>
     </attribute>
     <attribute name="horizontalHeaderMinimumSectionSize">
      <number>50</number>  <!-- 设置最小列宽 -->
     </attribute>
     <column>
      <property name="text">
       <string>ID</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>标题</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>分类</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>优先级</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>状态</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>删除时间</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>创建时间</string>
      </property>
     </column>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
</file>

<file path="dialogs/reminddialog.cpp">
#include "reminddialog.h"
</file>

<file path="dialogs/reminddialog.h">
// Reminder dialog
</file>

<file path="dialogs/settingdialog.cpp">
#include "settingdialog.h"
</file>

<file path="dialogs/settingdialog.h">
// Settings dialog
</file>

<file path="dialogs/tagmanagerdialog.h">
#ifndef TAGMANAGERDIALOG_H
#define TAGMANAGERDIALOG_H

#include <QDialog>
#include <QListWidget>
#include <QVariantMap>

namespace Ui {
class TagManagerDialog;
}

class TagManagerDialog : public QDialog
{
    Q_OBJECT

public:
    explicit TagManagerDialog(QWidget *parent = nullptr);
    ~TagManagerDialog();

private slots:
    void onAddTagClicked();
    void onDeleteTagClicked();
    void onRemoveRelationClicked();
    void onTagSelected(QListWidgetItem *item);
    void refreshTags();

private:
    Ui::TagManagerDialog *ui;
    QList<QVariantMap> allTags;

    void setupUI();
    void setupConnections();
};

#endif // TAGMANAGERDIALOG_H
</file>

<file path="dialogs/tagmanagerdialog.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TagManagerDialog</class>
 <widget class="QDialog" name="TagManagerDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>700</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>标签管理</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="titleLabel">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:14pt; font-weight:600; color:#657896;&quot;&gt;标签管理&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignmentFlag::AlignCenter</set>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Orientation::Horizontal</enum>
     </property>
     <property name="childrenCollapsible">
      <bool>false</bool>
     </property>
     <widget class="QWidget" name="leftWidget" native="true">
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <property name="leftMargin">
        <number>0</number>
       </property>
       <property name="topMargin">
        <number>0</number>
       </property>
       <property name="rightMargin">
        <number>0</number>
       </property>
       <property name="bottomMargin">
        <number>0</number>
       </property>
       <item>
        <widget class="QLabel" name="labelTags">
         <property name="styleSheet">
          <string>font-weight: bold; color: #657896; margin-bottom: 5px;</string>
         </property>
         <property name="text">
          <string>所有标签</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QListWidget" name="tagListWidget">
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <widget class="QLineEdit" name="tagNameInput">
           <property name="placeholderText">
            <string>新标签名称(6字以内)</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="addTagButton">
           <property name="text">
            <string>添加</string>
           </property>
           <property name="icon">
            <iconset resource="../resources/icons.qrc">
             <normaloff>:/icons/add_icon.png</normaloff>:/icons/add_icon.png</iconset>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QPushButton" name="deleteTagButton">
         <property name="styleSheet">
          <string>QPushButton { background-color: #C96A6A; border: none; color: white; padding: 6px; border-radius: 4px; } QPushButton:hover { background-color: #D47C7C; } QPushButton:pressed { background-color: #B05555; }</string>
         </property>
         <property name="text">
          <string>删除选中标签</string>
         </property>
         <property name="icon">
          <iconset resource="../resources/icons.qrc">
           <normaloff>:/icons/delete_icon.png</normaloff>:/icons/delete_icon.png</iconset>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="rightWidget" native="true">
      <layout class="QVBoxLayout" name="verticalLayout_3">
       <property name="leftMargin">
        <number>10</number>
       </property>
       <property name="topMargin">
        <number>0</number>
       </property>
       <property name="rightMargin">
        <number>0</number>
       </property>
       <property name="bottomMargin">
        <number>0</number>
       </property>
       <item>
        <widget class="QLabel" name="labelTasks">
         <property name="text">
          <string>关联的任务</string>
         </property>
         <property name="styleSheet">
          <string>font-weight: bold; color: #657896; margin-bottom: 5px;</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QTableWidget" name="taskTableWidget">
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="showGrid">
          <bool>true</bool>
         </property>
         <property name="gridStyle">
          <enum>Qt::SolidLine</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <property name="editTriggers">
          <enum>QAbstractItemView::NoEditTriggers</enum>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <column>
          <property name="text">
           <string>ID</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>标题</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>分类</string>
          </property>
         </column>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="removeRelationButton">
         <property name="text">
          <string>解除选中任务的关联</string>
         </property>
         <property name="icon">
          <iconset resource="../resources/icons.qrc">
           <normaloff>:/icons/delete_icon.png</normaloff>:/icons/delete_icon.png</iconset>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Orientation::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::StandardButton::Close</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources>
  <include location="../resources/icons.qrc"/>
 </resources>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>TagManagerDialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>
</file>

<file path="resources/styles/calendar.qss">
/* 日历整体背景 */
QCalendarWidget QWidget {
    background-color: #2d2d2d;
    color: #ffffff;
}

/* --- 顶部导航栏 --- */
QCalendarWidget QWidget#qt_calendar_navigationbar {
    background-color: #2d2d2d;
    min-height: 50px;
    border-bottom: 2px solid #3d3d3d;
}

/* 年份月份按钮 */
QCalendarWidget QToolButton {
    color: #ffffff;
    background-color: transparent;
    icon-size: 24px;
    border: none;
    font-weight: bold;
    font-size: 18px;
    height: 40px;
}
QCalendarWidget QToolButton:hover {
    background-color: #3d3d3d;
    border-radius: 4px;
}
QCalendarWidget QToolButton#qt_calendar_prevmonth {
    qproperty-icon: url(:/icons/left_arrow.png);
    width: 40px;
}
QCalendarWidget QToolButton#qt_calendar_nextmonth {
    qproperty-icon: url(:/icons/right_arrow.png);
    width: 40px;
}

/* 年份月份选择菜单 */
QCalendarWidget QMenu {
    background-color: #2d2d2d;
    color: white;
    border: 1px solid #3d3d3d;
}
QCalendarWidget QSpinBox {
    background-color: #2d2d2d;
    color: white;
    selection-background-color: #657896;
}

/* 日期表格区域 */
QCalendarWidget QAbstractItemView:enabled {
    background-color: #2d2d2d;
    color: #cccccc;
    selection-background-color: #657896;
    selection-color: white;
    font-size: 14px;
    outline: none;
}

QCalendarWidget QAbstractItemView:disabled {
    color: #555555;
}
</file>

<file path="resources/styles/kanban.qss">
/* 看板列容器 */
#kanbanColumn {
    background-color: #2d2d2d;
    border: 1px solid #3d3d3d;
    border-radius: 6px;
    margin: 0px 5px;
}

/* 看板列表控件 */
QListView {
    background-color: transparent;
    border: none;
    outline: none;
}

/* 滚动条样式 */
QScrollBar:vertical {
    border: none;
    background: #2d2d2d;
    width: 8px;
    margin: 0px;
}
QScrollBar::handle:vertical {
    background: #4d4d4d;
    min-height: 20px;
    border-radius: 4px;
}
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    height: 0px;
}

/* ---隐藏水平滚动条 --- */
QScrollBar:horizontal {
    height: 0px;
    background: transparent;
}
</file>

<file path="resources/styles/statistic.qss">
/* 统计页面全局 */
#statisticView, #statisticContentWidget {
    background-color: #1e1e1e;
}

/* 侧边栏样式 */
#statisticFilterSide {
    background-color: #252525;
    border-right: 1px solid #3d3d3d;
}

/* 消除标签黑条：强制背景透明 */
#statisticFilterSide QLabel, #filterLabel {
    background: transparent;
    color: #657896;
    font-weight: bold;
    margin-top: 5px;
}

/* 下拉框复用主窗口样式并确保透明度 */
QComboBox#filterCategoryCombo {
    background-color: #2d2d2d;
    color: #ffffff;
    border: 1px solid #3d3d3d;
    border-radius: 4px;
    padding: 0px 8px;
    min-height: 30px;
}

QComboBox#filterCategoryCombo:hover {
    border: 1px solid #657896;
}

/* 分类列表 */
#categoryListWidget {
    background-color: #1e1e1e;
    border: 1px solid #3d3d3d;
    border-radius: 4px;
    outline: none;
}

#categoryListWidget::item {
    background: transparent;
    padding: 8px;
    color: #cccccc;
    border-bottom: 1px solid #2d2d2d;
}

/* 勾选框：取消对勾图片，仅用颜色块表示选中 */
#categoryListWidget::indicator {
    width: 18px;
    height: 18px;
    border: 1px solid #4d4d4d;
    border-radius: 3px;
    background-color: #1e1e1e;
}

#categoryListWidget::indicator:checked {
    background-color: #657896;
    border-color: #657896;
    image: none; /* 彻底取消勾选图片 */
}

/* 概览卡片 */
.statCard {
    background-color: #2d2d2d;
    border: 1px solid #3d3d3d;
    border-radius: 10px;
}

#statTitleLabel, #statValueLabel, #overdueValueLabel {
    background: transparent;
}

#overdueValueLabel {
    color: #C96A6A;
    font-size: 24px;
    font-weight: bold;
}

#statValueLabel {
    color: #ffffff;
    font-size: 24px;
    font-weight: bold;
}
</file>

<file path="threads/remindthread.cpp">
#include "remindthread.h"
</file>

<file path="threads/remindthread.h">
// Reminder check thread
</file>

<file path="views/statisticview.cpp">
#include "statisticview.h"
#include "models/taskmodel.h"
#include "widgets/simplechartwidget.h"
#include "utils/exporter.h"
#include "database/database.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QSpinBox>
#include <QComboBox>
#include <QDateEdit>
#include <QListWidget>
#include <QScrollArea>
#include <QPushButton>
#include <QFileDialog>
#include <QMessageBox>
#include <QScrollBar>

StatisticView::StatisticView(QWidget *parent) : QWidget(parent)
{
    setupUI();
}

void StatisticView::setupUI()
{
    this->setObjectName("statisticView");
    QHBoxLayout *mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(0,0,0,0);
    mainLayout->setSpacing(0);

    // --- 1. 左侧筛选栏 ---
    QWidget *filterSide = new QWidget();
    filterSide->setObjectName("statisticFilterSide");
    filterSide->setFixedWidth(220);
    QVBoxLayout *fLayout = new QVBoxLayout(filterSide);
    fLayout->setContentsMargins(15, 20, 15, 20);
    fLayout->setSpacing(8);

    // 时间预设下拉框
    QLabel *timeLabel = new QLabel("时间范围预设:");
    timeLabel->setObjectName("filterLabel");
    fLayout->addWidget(timeLabel);

    m_timeRangeCombo = new QComboBox();
    m_timeRangeCombo->setObjectName("filterCategoryCombo");
    m_timeRangeCombo->addItems({"本周", "本日", "本月", "本年"});
    fLayout->addWidget(m_timeRangeCombo);

    // 常驻的日期选择器
    fLayout->addWidget(new QLabel("开始日期:"));
    m_startDateEdit = new QDateEdit(QDate::currentDate());
    m_startDateEdit->setCalendarPopup(true);
    fLayout->addWidget(m_startDateEdit);

    fLayout->addWidget(new QLabel("结束日期:"));
    m_endDateEdit = new QDateEdit(QDate::currentDate());
    m_endDateEdit->setCalendarPopup(true);
    m_endDateEdit->setMaximumDate(QDate::currentDate()); // 限制只能选今天及之前
    fLayout->addWidget(m_endDateEdit);

    // 关键布局：在此处加弹簧，将上方的“预设/日期”和下方的“分类/按钮”拉开
    fLayout->addStretch(1);

    // 底部区域：分类和按钮
    QLabel *cateLabel = new QLabel("任务分类 (多选):");
    cateLabel->setObjectName("filterLabel");
    fLayout->addWidget(cateLabel);

    m_categoryList = new QListWidget();
    m_categoryList->setObjectName("categoryListWidget");
    m_categoryList->setSpacing(2);
    m_categoryList->setFixedHeight(220); // 调整高度使整体更紧凑
    m_categoryList->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);

    QList<QVariantMap> cats = Database::instance().getAllCategories();
    for (const auto &c : cats) {
        QListWidgetItem *item = new QListWidgetItem(c["name"].toString(), m_categoryList);
        item->setData(Qt::UserRole, c["id"]);
        item->setCheckState(Qt::Checked);
        item->setSizeHint(QSize(0, 32));
    }
    fLayout->addWidget(m_categoryList);

    QPushButton *applyBtn = new QPushButton("更新分析");
    applyBtn->setObjectName("applyFilterBtn");
    applyBtn->setCursor(Qt::PointingHandCursor);
    fLayout->addWidget(applyBtn);

    // --- 2. 右侧滚动区域 ---
    QScrollArea *scroll = new QScrollArea();
    scroll->setWidgetResizable(true);
    scroll->setFrameShape(QFrame::NoFrame);
    scroll->verticalScrollBar()->setSingleStep(20);

    QWidget *content = new QWidget();
    content->setObjectName("statisticContentWidget");
    QVBoxLayout *cLayout = new QVBoxLayout(content);
    cLayout->setContentsMargins(25, 25, 25, 25);
    cLayout->setSpacing(30);

    // 指标卡片
    QHBoxLayout *cardLayout = new QHBoxLayout();
    auto makeCard = [&](const QString &t, QLabel*& l, bool isOverdue = false) {
        QFrame *f = new QFrame();
        f->setProperty("class", "statCard");
        QVBoxLayout *vl = new QVBoxLayout(f);
        QLabel *title = new QLabel(t);
        title->setObjectName("statTitleLabel");
        l = new QLabel("0");
        l->setObjectName(isOverdue ? "overdueValueLabel" : "statValueLabel");
        vl->addWidget(title); vl->addWidget(l, 0, Qt::AlignCenter);
        cardLayout->addWidget(f);
    };
    makeCard("总任务", m_totalLab);
    makeCard("已完成", m_compLab);
    makeCard("完成率", m_rateLab);
    makeCard("已逾期", m_overdueLab, true);
    makeCard("平均耗时(h)", m_avgTimeLab);
    makeCard("产生灵感", m_inspLab);
    cLayout->addLayout(cardLayout);

    // 图表绘制部分
    QHBoxLayout *row1 = new QHBoxLayout();
    m_catePie = new SimpleChartWidget(SimpleChartWidget::PieChart, "分类分布");
    m_trendLine = new SimpleChartWidget(SimpleChartWidget::LineChart, "完成动态趋势");
    row1->addWidget(m_catePie, 1);
    row1->addWidget(m_trendLine, 2);
    cLayout->addLayout(row1);

    QHBoxLayout *row2 = new QHBoxLayout();
    m_prioBar = new SimpleChartWidget(SimpleChartWidget::BarChart, "优先级分析");
    m_statusPie = new SimpleChartWidget(SimpleChartWidget::PieChart, "执行状态占比");
    row2->addWidget(m_prioBar, 1);
    row2->addWidget(m_statusPie, 1);
    cLayout->addLayout(row2);

    QHBoxLayout *btnLayout = new QHBoxLayout();
    QPushButton *btnXls = new QPushButton(" 导出数据报告(CSV)");
    btnXls->setObjectName("applyFilterBtn");
    btnXls->setIcon(QIcon(":/icons/export_icon.png"));
    btnLayout->addSpacing(
        0);
    QPushButton *btnPdf = new QPushButton(" 生成统计报表(PDF)");
    btnPdf->setObjectName("applyFilterBtn");
    btnPdf->setIcon(QIcon(":/icons/export_icon.png"));

    btnLayout->addStretch();
    btnLayout->addWidget(btnXls);
    btnLayout->addSpacing(10);
    btnLayout->addWidget(btnPdf);
    cLayout->addLayout(btnLayout);

    scroll->setWidget(content);
    mainLayout->addWidget(filterSide);
    mainLayout->addWidget(scroll);

    // 信号绑定
    connect(m_timeRangeCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &StatisticView::onTimeRangeTypeChanged);

    // 关键：手动修改日期也触发更新
    connect(m_startDateEdit, &QDateEdit::userDateChanged, this, &StatisticView::onFilterChanged);
    connect(m_endDateEdit, &QDateEdit::userDateChanged, this, &StatisticView::onFilterChanged);

    connect(applyBtn, &QPushButton::clicked, this, &StatisticView::onFilterChanged);
    connect(btnXls, &QPushButton::clicked, this, &StatisticView::onExportExcel);
    connect(btnPdf, &QPushButton::clicked, this, &StatisticView::onExportPDF);
    connect(m_categoryList, &QListWidget::itemClicked, this, [](QListWidgetItem* item){
        item->setCheckState(item->checkState() == Qt::Checked ? Qt::Unchecked : Qt::Checked);
    });

    // 初始化日期：触发一次“本周”的选择
    onTimeRangeTypeChanged(0);
}

StatisticModel::Filter StatisticView::getCurrentFilter() const
{
    StatisticModel::Filter f;

    // 直接从日期控件读取范围，不再关心下拉框选了什么
    f.start.setDate(m_startDateEdit->date());
    f.start.setTime(QTime(0, 0, 0));

    f.end.setDate(m_endDateEdit->date());
    f.end.setTime(QTime(23, 59, 59));

    for (int i = 0; i < m_categoryList->count(); ++i) {
        if (m_categoryList->item(i)->checkState() == Qt::Checked)
            f.categoryIds << m_categoryList->item(i)->data(Qt::UserRole).toInt();
    }
    return f;
}

void StatisticView::onTimeRangeTypeChanged(int index)
{
    QDate now = QDate::currentDate();
    QDate start, end;

    switch (index) {
    case 0: // 本周
        start = now.addDays(-(now.dayOfWeek() - 1));
        end = now.addDays(7 - now.dayOfWeek());
        break;
    case 1: // 本日
        start = now;
        end = now;
        break;
    case 2: // 本月
        start = QDate(now.year(), now.month(), 1);
        end = QDate(now.year(), now.month(), now.daysInMonth());
        break;
    case 3: // 本年
        start = QDate(now.year(), 1, 1);
        end = QDate(now.year(), 12, 31);
        break;
    }

    // 更新日期选择器的值
    m_startDateEdit->setDate(start);
    m_endDateEdit->setDate(end);

    // 自动触发一次数据更新
    onFilterChanged();
}

void StatisticView::onFilterChanged()
{
    if (!m_statModel) return;
    updateContent();
}

void StatisticView::updateContent()
{
    StatisticModel::Filter f = getCurrentFilter();

    // 趋势图逻辑路由
    QVector<int> trendData;
    QStringList labels;
    int days = f.start.date().daysTo(f.end.date());

    if (days == 0) { // 本日
        trendData = m_statModel->getHourlyTrend(f);
        for(int i=1; i<=24; ++i) labels << QString("%1h").arg(i);
    } else { // 本周或本月
        trendData = m_statModel->getDailyTrend(f);
        for(int i=1; i<=trendData.size(); ++i) labels << QString("d%1").arg(i);
    }
    m_trendLine->setTrendData(trendData, labels);

    m_catePie->setCategoryData(m_statModel->getTasksCountByCategory(f));
    m_prioBar->setCategoryData(m_statModel->getTasksCountByPriority(f));
    m_statusPie->setCategoryData(m_statModel->getTasksCountByStatus(f));
}

void StatisticView::setModels(TaskModel *taskModel, StatisticModel *statModel)
{
    m_taskModel = taskModel;
    m_statModel = statModel;
    onFilterChanged();
}

void StatisticView::refresh() { onFilterChanged(); }

void StatisticView::onExportExcel()
{
    // 生成默认文件名：yyMMddHHmm
    QString defaultFileName = QDateTime::currentDateTime().toString("yyMMddHHmm") + ".csv";

    QString fileName = QFileDialog::getSaveFileName(this, "导出任务数据(CSV)", defaultFileName, "CSV Files (*.csv)");
    if (fileName.isEmpty()) return;

    if (Exporter::exportTasksToCSV(fileName, m_taskModel, getCurrentFilter())) {
        QMessageBox::information(this, "成功", "数据已按当前筛选条件导出！");
    } else {
        QMessageBox::warning(this, "错误", "导出失败，请检查文件权限。");
    }
}

void StatisticView::onExportPDF()
{
    // 生成默认文件名：yyMMddHHmm
    QString defaultFileName = QDateTime::currentDateTime().toString("yyMMddHHmm") + ".pdf";

    QString fileName = QFileDialog::getSaveFileName(this, "导出统计报表(PDF)", defaultFileName, "PDF Files (*.pdf)");
    if (fileName.isEmpty()) return;

    // 抓取当前四个图表控件的截图
    QList<QPixmap> pixmaps;
    if (m_catePie) pixmaps << m_catePie->grab();
    if (m_trendLine) pixmaps << m_trendLine->grab();
    if (m_prioBar) pixmaps << m_prioBar->grab();
    if (m_statusPie) pixmaps << m_statusPie->grab();

    if (Exporter::exportReportToPDF(fileName, m_taskModel, m_statModel, getCurrentFilter(), pixmaps)) {
        QMessageBox::information(this, "成功", "统计报表已生成并包含图表分析！");
    } else {
        QMessageBox::warning(this, "错误", "生成PDF失败。");
    }
}
</file>

<file path="views/statisticview.h">
#ifndef STATISTICVIEW_H
#define STATISTICVIEW_H

#include <QWidget>
#include <QDateTime>
#include "models/statisticmodel.h"

class TaskModel;
class SimpleChartWidget;
class QLabel;
class QComboBox;
class QDateEdit;
class QListWidget;

class StatisticView : public QWidget
{
    Q_OBJECT
public:
    explicit StatisticView(QWidget *parent = nullptr);
    void setModels(TaskModel *taskModel, StatisticModel *statModel);
    void refresh();

private slots:
    void onFilterChanged();
    void onTimeRangeTypeChanged(int index);
    void onExportExcel();
    void onExportPDF();

private:
    StatisticModel *m_statModel;
    TaskModel *m_taskModel;

    // 筛选控件
    QComboBox *m_timeRangeCombo;
    QWidget *m_customDateWidget;
    QDateEdit *m_startDateEdit;
    QDateEdit *m_endDateEdit;
    QListWidget *m_categoryList;

    // 概览指标
    QLabel *m_totalLab, *m_compLab, *m_rateLab, *m_overdueLab, *m_avgTimeLab, *m_inspLab;

    // 图表
    SimpleChartWidget *m_catePie, *m_prioBar, *m_statusPie, *m_trendLine;

    void setupUI();
    StatisticModel::Filter getCurrentFilter() const;
    void updateContent();
};

#endif // STATISTICVIEW_H
</file>

<file path="widgets/comboboxdelegate.h">
#ifndef COMBOBOXDELEGATE_H
#define COMBOBOXDELEGATE_H

#include <QStyledItemDelegate>

class ComboBoxDelegate : public QStyledItemDelegate
{
    Q_OBJECT

public:
    explicit ComboBoxDelegate(QObject *parent = nullptr);

    QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                          const QModelIndex &index) const override;

    void setEditorData(QWidget *editor, const QModelIndex &index) const override;

    void setModelData(QWidget *editor, QAbstractItemModel *model,
                      const QModelIndex &index) const override;

    void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option,
                              const QModelIndex &index) const override;
};

#endif // COMBOBOXDELEGATE_H
</file>

<file path="widgets/prioritywidget.h">
#ifndef PRIORITYWIDGET_H
#define PRIORITYWIDGET_H

#include <QWidget>
#include <QButtonGroup>

class QPushButton;

class PriorityWidget : public QWidget
{
    Q_OBJECT

public:
    explicit PriorityWidget(QWidget *parent = nullptr);

    int getPriority() const;
    void setPriority(int priority);
    QString getPriorityText() const;
    QColor getPriorityColor() const;

    static QMap<int, QString> getPriorityOptions();
    static QString getPriorityText(int priority);
    static QColor getPriorityColor(int priority);

signals:
    void priorityChanged(int priority);

private slots:
    void onButtonClicked(int id);

private:
    QButtonGroup *m_buttonGroup;
    QPushButton *m_buttons[4];

    void setupUI();
    void updateButtonStyles();
};

#endif // PRIORITYWIDGET_H
</file>

<file path="widgets/simplechartwidget.cpp">
#include "simplechartwidget.h"
#include <QPainter>
#include <QPainterPath>
#include <QtMath>
#include <QDebug>

SimpleChartWidget::SimpleChartWidget(ChartType type, QString title, QWidget *parent)
    : QWidget(parent), m_type(type), m_title(title)
{
    setMinimumSize(300, 250);
    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
}

void SimpleChartWidget::setCategoryData(const QMap<QString, int> &data)
{
    m_categoryData = data;
    update();
}

void SimpleChartWidget::setTrendData(const QVector<int> &data, const QStringList &labels)
{
    m_trendValues = data;
    m_trendLabels = labels;
    update();
}

void SimpleChartWidget::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    // 1. 背景绘制：使用圆角矩形，去除黑色长条干扰
    painter.setPen(Qt::NoPen);
    painter.setBrush(QColor("#2d2d2d"));
    painter.drawRoundedRect(rect(), 10, 10);

    // 2. 边框
    painter.setPen(QPen(QColor("#3d3d3d"), 1));
    painter.setBrush(Qt::NoBrush);
    painter.drawRoundedRect(rect().adjusted(0, 0, -1, -1), 10, 10);

    // 3. 标题
    painter.setPen(Qt::white);
    QFont font = painter.font();
    font.setBold(true);
    font.setPointSize(11);
    painter.setFont(font);
    QRect titleRect(0, 10, width(), 30);
    painter.drawText(titleRect, Qt::AlignCenter, m_title);

    // 4. 绘图区域：增加底部边距（从 -20 改为 -45），为标签留出更多空间
    QRect chartRect = rect().adjusted(30, 50, -30, -45);

    if (m_type == PieChart) {
        drawPieChart(painter, chartRect);
    } else if (m_type == BarChart) {
        drawBarChart(painter, chartRect);
    } else if (m_type == LineChart) {
        drawLineChart(painter, chartRect);
    }
}

void SimpleChartWidget::drawPieChart(QPainter &painter, const QRect &rect)
{
    if (m_categoryData.isEmpty()) return;

    int total = 0;
    for (int val : m_categoryData) total += val;
    if (total == 0) return;

    int size = qMin(rect.width(), rect.height());
    // 留出右侧图例空间
    int pieSize = size * 0.8;
    QRect pieRect(rect.left(), rect.top() + (rect.height() - pieSize)/2, pieSize, pieSize);

    int startAngle = 0;
    int colorIndex = 0;

    // 绘制饼图
    for (auto it = m_categoryData.begin(); it != m_categoryData.end(); ++it) {
        if (it.value() == 0) continue;

        int spanAngle = (it.value() * 360 * 16) / total;
        painter.setBrush(getColor(colorIndex));
        painter.setPen(Qt::NoPen);
        painter.drawPie(pieRect, startAngle, spanAngle);

        startAngle += spanAngle;
        colorIndex++;
    }

    // 绘制图例
    int legendX = pieRect.right() + 20;
    int legendY = rect.top() + 20;
    colorIndex = 0;
    QFont legendFont = painter.font();
    legendFont.setPointSize(9);
    legendFont.setBold(false);
    painter.setFont(legendFont);

    for (auto it = m_categoryData.begin(); it != m_categoryData.end(); ++it) {
        if (it.value() == 0) continue;

        painter.setBrush(getColor(colorIndex));
        painter.drawRect(legendX, legendY, 12, 12);

        painter.setPen(QColor("#cccccc"));
        QString text = QString("%1 (%2)").arg(it.key()).arg(it.value());
        painter.drawText(legendX + 20, legendY + 11, text);

        legendY += 25;
        colorIndex++;
    }
}

void SimpleChartWidget::drawBarChart(QPainter &painter, const QRect &rect)
{
    if (m_categoryData.isEmpty()) return;

    int maxVal = 0;
    for (int val : m_categoryData) if (val > maxVal) maxVal = val;
    if (maxVal == 0) maxVal = 1;

    int count = m_categoryData.size();
    int barWidth = (rect.width() / count) * 0.6;
    int spacing = (rect.width() / count) * 0.4;

    int x = rect.left() + spacing / 2;
    int colorIndex = 0;

    QFont labelFont = painter.font();
    labelFont.setPointSize(9);
    labelFont.setBold(false);
    painter.setFont(labelFont);

    for (auto it = m_categoryData.begin(); it != m_categoryData.end(); ++it) {
        int barHeight = (int)((double)it.value() / maxVal * (rect.height() - 20));

        QRect barRect(x, rect.bottom() - barHeight, barWidth, barHeight);

        painter.setBrush(getColor(colorIndex));
        painter.setPen(Qt::NoPen);
        painter.drawRect(barRect);

        // 数值：
        painter.setPen(Qt::white);
        painter.setBackgroundMode(Qt::TransparentMode); // 确保文字背景透明
        painter.drawText(barRect.adjusted(0, -20, 0, 0), Qt::AlignCenter | Qt::AlignBottom, QString::number(it.value()));

        // 标签：下移位置
        painter.setPen(QColor("#cccccc"));
        QRect labelRect(x - 5, rect.bottom() + 10, barWidth + 10, 20);
        painter.drawText(labelRect, Qt::AlignCenter, it.key());

        x += barWidth + spacing;
        colorIndex++;
    }
}

void SimpleChartWidget::drawLineChart(QPainter &painter, const QRect &rect)
{
    if (m_trendValues.isEmpty()) return;

    int maxVal = 0;
    for (int val : m_trendValues) if (val > maxVal) maxVal = val;
    maxVal = maxVal < 5 ? 5 : maxVal + 1;

    painter.setPen(QColor("#555555"));
    painter.drawLine(rect.bottomLeft(), rect.bottomRight());
    painter.drawLine(rect.bottomLeft(), rect.topLeft());

    int count = m_trendValues.size();
    double stepX = count > 1 ? (double)rect.width() / (count - 1) : 0;

    QVector<QPointF> points;
    for (int i = 0; i < count; ++i) {
        double x = rect.left() + i * stepX;
        double y = rect.bottom() - ((double)m_trendValues[i] / maxVal * rect.height());
        points.append(QPointF(x, y));

        // 绘制 1h, d1 等标签
        if (i % (count > 15 ? 5 : 1) == 0) { // 如果点太多（如一月），每5天显示一个标签
            painter.setPen(QColor("#888888"));
            painter.drawText(x - 20, rect.bottom() + 10, 40, 20, Qt::AlignCenter, m_trendLabels.at(i));
        }
    }

    painter.setRenderHint(QPainter::Antialiasing);
    painter.setPen(QPen(getColor(6), 2));
    if (points.size() > 1) painter.drawPolyline(points.data(), points.size());

    for (int j = 0; j < points.size(); ++j) {
        painter.setBrush(QColor("#2d2d2d"));
        painter.drawEllipse(points[j], 3, 3);
        if (m_trendValues[j] > 0) {
            painter.setPen(Qt::white);
            painter.drawText(points[j].x() - 15, points[j].y() - 20, 30, 15, Qt::AlignCenter, QString::number(m_trendValues[j]));
        }
    }
}

QColor SimpleChartWidget::getColor(int index) const
{
    static const QStringList palette = {
        "#7696B3", // 钢蓝
        "#D69E68", // 大地橙
        "#7FA882", // 鼠尾草绿
        "#C96A6A", // 柔和砖红
        "#B48EAD", // 莫兰迪紫
        "#8C949E", // 冷灰
        "#88C0D0", // 北欧蓝
        "#EBCB8B", // 麦穗黄
        "#BF616A"  // 浆果红
    };
    return QColor(palette[index % palette.size()]);
}
</file>

<file path="widgets/simplechartwidget.h">
#ifndef SIMPLECHARTWIDGET_H
#define SIMPLECHARTWIDGET_H

#include <QWidget>
#include <QMap>
#include <QDate>

class SimpleChartWidget : public QWidget
{
    Q_OBJECT

public:
    enum ChartType { PieChart, BarChart, LineChart };
    explicit SimpleChartWidget(ChartType type, QString title, QWidget *parent = nullptr);

    void setCategoryData(const QMap<QString, int> &data);
    void setTrendData(const QVector<int> &data, const QStringList &labels);

protected:
    void paintEvent(QPaintEvent *event) override;

private:
    ChartType m_type;
    QString m_title;
    QMap<QString, int> m_categoryData;
    QVector<int> m_trendValues;
    QStringList m_trendLabels;

    void drawPieChart(QPainter &painter, const QRect &rect);
    void drawBarChart(QPainter &painter, const QRect &rect);
    void drawLineChart(QPainter &painter, const QRect &rect);

    QColor getColor(int index) const;
};

#endif // SIMPLECHARTWIDGET_H
</file>

<file path="widgets/statuswidget.h">
#ifndef STATUSWIDGET_H
#define STATUSWIDGET_H

#include <QWidget>
#include <QButtonGroup>

class QPushButton;

class StatusWidget : public QWidget
{
    Q_OBJECT

public:
    explicit StatusWidget(QWidget *parent = nullptr);

    int getStatus() const;
    void setStatus(int status);
    QString getStatusText() const;
    QColor getStatusColor() const;

    static QMap<int, QString> getStatusOptions();
    static QString getStatusText(int status);
    static QColor getStatusColor(int status);

signals:
    void statusChanged(int status);

private slots:
    void onButtonClicked(int id);

private:
    QButtonGroup *m_buttonGroup;
    QPushButton *m_buttons[4];

    void setupUI();
};

#endif // STATUSWIDGET_H
</file>

<file path="widgets/tagwidget.h">
#ifndef TAGWIDGET_H
#define TAGWIDGET_H

#include <QWidget>
#include <QList>
#include <QVariantMap>

class QHBoxLayout;
class QPushButton;

class TagWidget : public QWidget
{
    Q_OBJECT

public:
    explicit TagWidget(QWidget *parent = nullptr);

    void addTag(const QString &name, const QString &color = "#657896");
    void addAvailableTag(const QString &name, const QString &color = "#657896");
    void removeTag(const QString &name);
    void clearTags();

    QList<QVariantMap> getTags() const;
    bool hasTag(const QString &name) const;

    static QString generateColor(const QString &text);

signals:
    void tagAdded(const QString &name);
    void tagRemoved(const QString &name);

protected:
    void paintEvent(QPaintEvent *event) override;

private slots:
    void onTagButtonClicked();

private:
    QHBoxLayout *m_layout;
    QList<QPushButton*> m_tagButtons;
    QList<QVariantMap> m_availableTags;

    void setupUI();
    QPushButton* createTagButton(const QString &name, const QString &color);
    void updateLayout();
};

#endif // TAGWIDGET_H
</file>

<file path="widgets/watermarkwidget.h">
#ifndef WATERMARKWIDGET_H
#define WATERMARKWIDGET_H

#include <QWidget>
#include <QPainter>
#include <QPaintEvent>
#include <QResizeEvent>

class WatermarkWidget : public QWidget
{
    Q_OBJECT

public:
    explicit WatermarkWidget(const QString &text, QWidget *parent = nullptr);

protected:
    void paintEvent(QPaintEvent *event) override;
    void resizeEvent(QResizeEvent *event) override;

private:
    QString watermarkText;
};

#endif // WATERMARKWIDGET_H
</file>

<file path="dialogs/inspirationdialog.h">
#ifndef INSPIRATIONDIALOG_H
#define INSPIRATIONDIALOG_H

#include <QDialog>
#include <QVariantMap>

class QTextEdit;
class QLineEdit;

class InspirationDialog : public QDialog
{
    Q_OBJECT

public:
    explicit InspirationDialog(QWidget *parent = nullptr);
    explicit InspirationDialog(const QVariantMap &data, QWidget *parent = nullptr);

    QVariantMap getData() const;

private slots:
    void onSave();

private:
    QTextEdit *m_contentEdit;
    QLineEdit *m_tagsEdit;
    int m_id;

    void setupUI();
    void populateData(const QVariantMap &data);
};

#endif // INSPIRATIONDIALOG_H
</file>

<file path="models/inspirationmodel.h">
#ifndef INSPIRATIONMODEL_H
#define INSPIRATIONMODEL_H

#include <QAbstractTableModel>
#include <QSqlDatabase>
#include <QList>
#include <QDateTime>

class InspirationModel : public QAbstractTableModel
{
    Q_OBJECT

public:
    explicit InspirationModel(QObject *parent = nullptr);
    ~InspirationModel();

    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
    int columnCount(const QModelIndex &parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
    Qt::ItemFlags flags(const QModelIndex &index) const override;

    bool addInspiration(const QString &content, const QString &tags = "");
    bool updateInspiration(int id, const QString &content, const QString &tags = "");
    bool deleteInspiration(int id);
    bool deleteInspirations(const QList<int> &ids);

    QList<QVariantMap> getAllInspirations() const;
    QList<QVariantMap> getInspirationsByDate(const QDate &date) const;
    QList<QVariantMap> getInspirationsByTag(const QString &tag) const;
    QList<QVariantMap> searchInspirations(const QString &keyword) const;

    int getInspirationCount() const;
    QList<QDate> getDatesWithInspirations() const;
    QList<QDate> getDatesWithInspirations(const QStringList &filterTags, bool matchAll) const;
    QStringList getAllTags() const;

    void refresh();

    bool restoreInspiration(int id);
    bool permanentDeleteInspiration(int id);
    QList<QVariantMap> getDeletedInspirations() const;
    bool emptyRecycleBin();

    bool renameTag(const QString &oldName, const QString &newName);
    bool removeTagFromAll(const QString &tagName);

signals:
    void inspirationAdded(int id);
    void inspirationUpdated(int id);
    void inspirationDeleted(int id);

private:
    struct InspirationItem {
        int id;
        QString content;
        QString tags;
        QDateTime createdAt;
        QDateTime updatedAt;

        QVariantMap toVariantMap() const {
            QVariantMap map;
            map["id"] = id;
            map["content"] = content;
            map["tags"] = tags;
            map["created_at"] = createdAt;
            map["updated_at"] = updatedAt;
            return map;
        }

        QString preview(int maxLength = 50) const {
            if (content.length() <= maxLength) {
                return content;
            }
            return content.left(maxLength) + "...";
        }

        QStringList tagList() const {
            if (tags.isEmpty()) return QStringList();
            return tags.split(",", Qt::SkipEmptyParts);
        }
    };

    QList<InspirationItem> inspirations;
    QSqlDatabase db;

    void loadInspirations();
    QDateTime getCurrentTimestamp() const;
};

#endif // INSPIRATIONMODEL_H
</file>

<file path="models/statisticmodel.cpp">
#include "statisticmodel.h"
#include "database/database.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QVariant>
#include <QDebug>

StatisticModel::StatisticModel(QObject *parent) : QObject(parent) {}

QString StatisticModel::buildCategoryInClause(const QList<int> &ids) const
{
    if (ids.isEmpty()) return "";
    QStringList strIds;
    for (int id : ids) strIds << QString::number(id);
    return QString(" AND category_id IN (%1) ").arg(strIds.join(","));
}

QVariantMap StatisticModel::getOverviewStats(const Filter &f) const
{
    QVariantMap res;
    QString catClause = buildCategoryInClause(f.categoryIds);
    QString timeClause = " AND deadline BETWEEN ? AND ? ";

    auto getCount = [&](const QString &extra) {
        QSqlQuery q;
        q.prepare("SELECT COUNT(*) FROM tasks WHERE is_deleted = 0 " + timeClause + catClause + extra);
        q.addBindValue(f.start);
        q.addBindValue(f.end);
        if (q.exec() && q.next()) return q.value(0).toInt();
        return 0;
    };

    res["total"] = getCount("");
    res["completed"] = getCount(" AND status = 2 ");
    res["overdue"] = getCount(" AND status != 2 AND deadline < datetime('now','localtime') ");

    int total = res["total"].toInt();
    res["rate"] = total > 0 ? (double)res["completed"].toInt() / total * 100.0 : 0.0;

    return res;
}

QMap<QString, int> StatisticModel::getTasksCountByCategory(const Filter &f) const
{
    QMap<QString, int> result;
    QSqlQuery q;
    q.prepare("SELECT c.name, COUNT(t.id) as cnt FROM tasks t "
              "JOIN task_categories c ON t.category_id = c.id "
              "WHERE t.is_deleted = 0 AND t.deadline BETWEEN ? AND ? "
              + buildCategoryInClause(f.categoryIds) + " GROUP BY c.name");
    q.addBindValue(f.start);
    q.addBindValue(f.end);
    if (q.exec()) while (q.next()) result[q.value(0).toString()] = q.value(1).toInt();
    return result;
}

QMap<QString, int> StatisticModel::getTasksCountByPriority(const Filter &f) const
{
    QMap<QString, int> result;
    // 显式初始化，确保 0 值也显示
    result["紧急"] = 0; result["重要"] = 0; result["普通"] = 0; result["不急"] = 0;

    QStringList names = {"紧急", "重要", "普通", "不急"};
    QSqlQuery q;
    q.prepare("SELECT priority, COUNT(*) FROM tasks WHERE is_deleted = 0 AND deadline BETWEEN ? AND ? "
              + buildCategoryInClause(f.categoryIds) + " GROUP BY priority");
    q.addBindValue(f.start);
    q.addBindValue(f.end);
    if (q.exec()) {
        while (q.next()) {
            int p = q.value(0).toInt();
            if (p >= 0 && p < names.size()) result[names[p]] = q.value(1).toInt();
        }
    }
    return result;
}

QMap<QString, int> StatisticModel::getTasksCountByStatus(const Filter &f) const
{
    QMap<QString, int> result;
    QStringList names = {"待办", "进行中", "已完成", "已延期"};
    QSqlQuery q;
    q.prepare("SELECT status, COUNT(*) FROM tasks WHERE is_deleted = 0 AND deadline BETWEEN ? AND ? "
              + buildCategoryInClause(f.categoryIds) + " GROUP BY status");
    q.addBindValue(f.start);
    q.addBindValue(f.end);
    if (q.exec()) while (q.next()) result[names.value(q.value(0).toInt(), "未知")] = q.value(1).toInt();
    return result;
}

QVector<int> StatisticModel::getHourlyTrend(const Filter &f) const
{
    QVector<int> data(24, 0);
    int currentHour = QDateTime::currentDateTime().time().hour();
    QSqlQuery q;
    q.prepare("SELECT strftime('%H', completed_at) as hour, COUNT(*) FROM tasks "
              "WHERE is_deleted = 0 AND status = 2 AND date(completed_at) = date(?) "
              + buildCategoryInClause(f.categoryIds) + " GROUP BY hour");
    q.addBindValue(f.start);
    if (q.exec()) {
        while (q.next()) {
            int h = q.value(0).toInt();
            if (h >= 0 && h < 24) data[h] = q.value(1).toInt();
        }
    }
    for(int i = currentHour + 1; i < 24; ++i) data[i] = 0;
    return data;
}

QVector<int> StatisticModel::getDailyTrend(const Filter &f) const
{
    int days = f.start.date().daysTo(f.end.date()) + 1;
    if (days <= 0) return QVector<int>();
    QVector<int> data(days, 0);
    QDate today = QDate::currentDate();
    QSqlQuery q;
    q.prepare("SELECT date(completed_at) as d, COUNT(*) FROM tasks "
              "WHERE is_deleted = 0 AND status = 2 AND completed_at BETWEEN ? AND ? "
              + buildCategoryInClause(f.categoryIds) + " GROUP BY d");
    q.addBindValue(f.start);
    q.addBindValue(f.end);
    if (q.exec()) {
        while (q.next()) {
            QDate d = QDate::fromString(q.value(0).toString(), "yyyy-MM-dd");
            int idx = f.start.date().daysTo(d);
            if (idx >= 0 && idx < days) data[idx] = q.value(1).toInt();
        }
    }
    for(int i = 0; i < days; ++i) {
        if (f.start.date().addDays(i) > today) data[i] = 0;
    }
    return data;
}

double StatisticModel::getAverageCompletionTime(const Filter &f) const
{
    QSqlQuery q;
    q.prepare("SELECT AVG((julianday(completed_at) - julianday(created_at)) * 24) FROM tasks "
              "WHERE is_deleted = 0 AND status = 2 AND completed_at BETWEEN ? AND ? "
              + buildCategoryInClause(f.categoryIds));
    q.addBindValue(f.start);
    q.addBindValue(f.end);
    if (q.exec() && q.next()) return q.value(0).toDouble();
    return 0.0;
}

int StatisticModel::getInspirationCount(const Filter &f) const
{
    QSqlQuery q;
    q.prepare("SELECT COUNT(*) FROM inspirations WHERE is_deleted = 0 AND created_at BETWEEN ? AND ?");
    q.addBindValue(f.start);
    q.addBindValue(f.end);
    if (q.exec() && q.next()) return q.value(0).toInt();
    return 0;
}
</file>

<file path="models/statisticmodel.h">
#ifndef STATISTICMODEL_H
#define STATISTICMODEL_H

#include <QObject>
#include <QMap>
#include <QDateTime>
#include <QList>

class StatisticModel : public QObject
{
    Q_OBJECT

public:
    explicit StatisticModel(QObject *parent = nullptr);

    struct Filter {
        QDateTime start;
        QDateTime end;
        QList<int> categoryIds;
    };

    // 核心统计方法
    QVariantMap getOverviewStats(const Filter &f) const;
    QMap<QString, int> getTasksCountByCategory(const Filter &f) const;
    QMap<QString, int> getTasksCountByPriority(const Filter &f) const;
    QMap<QString, int> getTasksCountByStatus(const Filter &f) const;
    QMap<QDate, int> getDailyCompletionTrend(const Filter &f) const;

    // 趋势图新函数
    QVector<int> getHourlyTrend(const Filter &f) const;
    QVector<int> getDailyTrend(const Filter &f) const;

    double getAverageCompletionTime(const Filter &f) const;
    int getInspirationCount(const Filter &f) const;

private:
    QString buildCategoryInClause(const QList<int> &ids) const;
};

#endif // STATISTICMODEL_H
</file>

<file path="models/taskitem.h">
#ifndef TASKITEM_H
#define TASKITEM_H

#include <QString>
#include <QDateTime>
#include <QVariant>
#include <QList>

struct TaskItem {
    int id;
    QString title;
    QString description;
    int categoryId;
    QString categoryName;
    QString categoryColor;
    int priority;
    int status;
    QDateTime startTime;
    QDateTime deadline;
    QDateTime remindTime;
    bool isReminded;
    bool isDeleted;
    QDateTime createdAt;
    QDateTime updatedAt;
    QDateTime completedAt;
    QList<int> tagIds;
    QList<QString> tagNames;
    QList<QString> tagColors;

    QVariantMap toVariantMap() const;
    static TaskItem fromVariantMap(const QVariantMap &data);

    QString priorityText() const;
    QString statusText() const;
    QColor priorityColor() const;
    QColor statusColor() const;
    bool isOverdue() const;
};

#endif // TASKITEM_H
</file>

<file path="utils/exporter.cpp">
#include "exporter.h"
#include "models/taskmodel.h"
#include <QFile>
#include <QTextStream>
#include <QPrinter>
#include <QTextDocument>
#include <QDateTime>
#include <QBuffer>
#include <QTextOption>

bool Exporter::exportTasksToCSV(const QString &filePath, TaskModel *model, const StatisticModel::Filter &f)
{
    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) return false;

    QTextStream out(&file);
    out << QString::fromUtf8("\xEF\xBB\xBF");
    // 更新表头：插入创建时间和完成时间
    out << "ID,标题,分类,优先级,状态,创建时间,完成时间,截止时间,描述\n";

    QList<QVariantMap> allTasks = model->getAllTasks(false);
    for (const QVariantMap &task : allTasks) {
        QDateTime dl = task["deadline"].toDateTime();
        if (dl < f.start || dl > f.end) continue;
        if (!f.categoryIds.isEmpty() && !f.categoryIds.contains(task["category_id"].toInt())) continue;

        QStringList row;
        row << task["id"].toString();
        row << "\"" + task["title"].toString().replace("\"", "\"\"") + "\"";

        // 分类名称（现在已有值）
        QString catName = task["category_name"].toString();
        row << (catName.isEmpty() ? "未分类" : catName);

        int p = task["priority"].toInt();
        row << (p==0?"紧急": (p==1?"重要": (p==2?"普通":"不急")));

        int s = task["status"].toInt();
        row << (s==0?"待办": (s==1?"进行中": (s==2?"已完成":"已延期")));

        // 创建日期
        row << task["created_at"].toDateTime().toString("yyyy-MM-dd HH:mm");

        // 完成日期
        QDateTime compAt = task["completed_at"].toDateTime();
        row << (compAt.isValid() ? compAt.toString("yyyy-MM-dd HH:mm") : "-");

        row << dl.toString("yyyy-MM-dd HH:mm");
        row << "\"" + task["description"].toString().replace("\"", "\"\"").replace("\n", " ") + "\"";

        out << row.join(",") << "\n";
    }
    file.close();
    return true;
}

bool Exporter::exportReportToPDF(const QString &filePath, TaskModel *taskModel, StatisticModel *statModel,
                                 const StatisticModel::Filter &f, const QList<QPixmap> &chartPixmaps)
{
    QPrinter printer(QPrinter::HighResolution);
    printer.setOutputFormat(QPrinter::PdfFormat);
    printer.setOutputFileName(filePath);
    printer.setPageMargins(QMarginsF(5, 5, 5, 5), QPageLayout::Millimeter);

    QVariantMap stats = statModel->getOverviewStats(f);
    QTextDocument doc;

    auto pixmapToBase64 = [](const QPixmap &pix) {
        QByteArray ba;
        QBuffer buf(&ba);
        pix.save(&buf, "PNG");
        return QString("data:image/png;base64,") + ba.toBase64();
    };

    QString html = "<html><body style='font-family: Arial, sans-serif;'>";
    html += "<h1 style='text-align: center; color: #657896;'>个人工作统计报表</h1>";
    html += QString("<p style='text-align: center;'>统计周期: %1 至 %2</p>")
                .arg(f.start.toString("yyyy-MM-dd")).arg(f.end.toString("yyyy-MM-dd"));

    html += "<h2>1. 数据指标</h2>";
    html += "<div style='font-family: \"Courier New\", monospace; font-size: 12pt;'>";
    html += "<table width='100%' style='border-collapse: collapse;'>";
    html += "<tr>"
            "<td style='text-align: left; width: 33%; padding: 0;'>"
            "<span style='display: inline-block; width: 100px;'>任务总数:" + stats["total"].toString() + "</span>"
                                          "</td>"
                                          "<td style='text-align: left; width: 33%; padding: 0;'>"
                                          "<span style='display: inline-block; width: 120px;'>已完成:" + stats["completed"].toString() + "</span>"
                                              "</td>"
                                              "<td style='text-align: left; width: 34%; padding: 0;'>"
                                              "<span style='display: inline-block; width: 120px;'>完成率:" + QString::number(stats["rate"].toDouble(), 'f', 1) + "%</span>"
                                                                  "</td>"
                                                                  "</tr>";
    html += "<tr>"
            "<td style='text-align: left; width: 33%; padding: 0;'>"
            "<span style='display: inline-block; width: 100px;'>已逾期:" + stats["overdue"].toString() + "</span>"
                                            "</td>"
                                            "<td style='text-align: left; width: 33%; padding: 0;'>"
                                            "<span style='display: inline-block; width: 120px;'>平均完成耗时:" + QString::number(statModel->getAverageCompletionTime(f), 'f', 1) + "h</span>"
                                                                                "</td>"
                                                                                "<td style='text-align: left; width: 34%; padding: 0;'>"
                                                                                "<span style='display: inline-block; width: 120px;'>产生灵感:" + QString::number(statModel->getInspirationCount(f)) + "</span>"
                                                                   "</td>"
                                                                   "</tr>";
    html += "</table></div>";

    // 插入图表图片
    if (chartPixmaps.size() >= 4) {
        html += "<h2>2. 统计图表分析</h2>";
        html += "<table width='100%'>";
        html += "<tr><td><img src='" + pixmapToBase64(chartPixmaps[0]) + "' width='300'></td>";
        html += "<td><img src='" + pixmapToBase64(chartPixmaps[1]) + "' width='400'></td></tr>";
        html += "<tr><td><img src='" + pixmapToBase64(chartPixmaps[2]) + "' width='300'></td>";
        html += "<td><img src='" + pixmapToBase64(chartPixmaps[3]) + "' width='300'></td></tr>";
        html += "</table>";
    }

    html += "<h2 style='margin-top: 10px; margin-bottom: 5px;'>3. 任务清单详情</h2>";
    html += "<table border='1' cellspacing='0' cellpadding='4' "
            "style='width: 100%; border-collapse: collapse; font-size: 10pt;'>";

    // 表头
    html += "<tr style='background-color: #657896; color: white;'>"
            "<th style='text-align: center; padding: 8px; font-weight: bold;'>标题</th>"
            "<th style='text-align: center; padding: 8px; font-weight: bold;'>分类</th>"
            "<th style='text-align: center; padding: 8px; font-weight: bold;'>状态</th>"
            "<th style='text-align: center; padding: 8px; font-weight: bold;'>创建日期</th>"
            "<th style='text-align: center; padding: 8px; font-weight: bold;'>完成日期</th>"
            "<th style='text-align: center; padding: 8px; font-weight: bold;'>截止日期</th>"
            "</tr>";

    QList<QVariantMap> allTasks = taskModel->getAllTasks(false);
    int rowCount = 0;

    for (const QVariantMap &task : allTasks) {
        QDateTime dl = task["deadline"].toDateTime();
        if (dl < f.start || dl > f.end) continue;
        if (!f.categoryIds.isEmpty() && !f.categoryIds.contains(task["category_id"].toInt())) continue;

        int s = task["status"].toInt();
        QString sText = (s==0?"待办": (s==1?"进行中": (s==2?"已完成":"已延期")));
        QString sColor = (s==0?"#FF9800": (s==1?"#2196F3": (s==2?"#4CAF50":"#F44336")));

        QString catName = task["category_name"].toString();
        if (catName.isEmpty()) catName = "未分类";

        QString createStr = task["created_at"].toDateTime().toString("yyyy-MM-dd");
        QDateTime compAt = task["completed_at"].toDateTime();
        QString compStr = compAt.isValid() ? compAt.toString("yyyy-MM-dd") : "-";

        // 交替行颜色
        QString bgColor = (rowCount % 2 == 0) ? "#ffffff" : "#f8f9fa";
        html += QString("<tr style='background-color: %1;'>"
                        "<td style='padding: 6px; border: 1px solid #ddd; text-align: center;'>%2</td>"
                        "<td style='padding: 6px; border: 1px solid #ddd; text-align: center;'>%3</td>"
                        "<td style='padding: 6px; border: 1px solid #ddd; text-align: center; color: %4; font-weight: bold;'>%5</td>"
                        "<td style='padding: 6px; border: 1px solid #ddd; text-align: center;'>%6</td>"
                        "<td style='padding: 6px; border: 1px solid #ddd; text-align: center;'>%7</td>"
                        "<td style='padding: 6px; border: 1px solid #ddd; text-align: center;'>%8</td>"
                        "</tr>")
                    .arg(bgColor)
                    .arg(task["title"].toString())
                    .arg(catName)
                    .arg(sColor)
                    .arg(sText)
                    .arg(createStr)
                    .arg(compStr)
                    .arg(dl.toString("yyyy-MM-dd"));

        rowCount++;
    }

    html += "</table>";

    // 如果没有任务记录
    if (rowCount == 0) {
        html += "<div style='text-align: center; padding: 30px; font-size: 12pt; color: #999;'>暂无任务记录</div>";
    }

    html += QString("<div style='margin-top: 20px; padding-top: 10px; border-top: 1px solid #ddd; text-align: right; color: #666; font-size: 10pt;'>"
                    "生成时间: %1 | 共 %2 条任务记录"
                    "</div>")
                .arg(QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss"))
                .arg(rowCount);

    html += "</body></html>";

    doc.setHtml(html);

    // 设置文档属性
    QTextOption option;
    option.setWrapMode(QTextOption::WordWrap);
    doc.setDefaultTextOption(option);

    // 设置页面大小
    doc.setPageSize(printer.pageRect(QPrinter::Point).size());

    // 打印
    doc.print(&printer);

    return true;
}
</file>

<file path="utils/exporter.h">
#ifndef EXPORTER_H
#define EXPORTER_H

#include <QString>
#include <QList>
#include <QVariantMap>
#include <QPixmap>
#include "models/statisticmodel.h"

class TaskModel;

class Exporter
{
public:
    static bool exportTasksToCSV(const QString &filePath, TaskModel *model, const StatisticModel::Filter &f);

    static bool exportReportToPDF(const QString &filePath, TaskModel *taskModel, StatisticModel *statModel,
                                  const StatisticModel::Filter &f, const QList<QPixmap> &chartPixmaps);
};

#endif // EXPORTER_H
</file>

<file path="widgets/comboboxdelegate.cpp">
#include "comboboxdelegate.h"
#include "models/taskmodel.h"
#include <QComboBox>
#include <QApplication>

ComboBoxDelegate::ComboBoxDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
{
}

QWidget *ComboBoxDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                                        const QModelIndex &index) const
{
    Q_UNUSED(option);

    if (index.column() != 3 && index.column() != 4) {
        return QStyledItemDelegate::createEditor(parent, option, index);
    }

    QComboBox *editor = new QComboBox(parent);
    editor->setFrame(false);

    if (index.column() == 3) {
        QMap<int, QString> options = TaskModel::getPriorityOptions();
        for (auto it = options.begin(); it != options.end(); ++it) {
            editor->addItem(it.value(), it.key());
        }
    } else if (index.column() == 4) {
        QMap<int, QString> options = TaskModel::getStatusOptions();
        for (auto it = options.begin(); it != options.end(); ++it) {
            editor->addItem(it.value(), it.key());
        }
    }

    return editor;
}

void ComboBoxDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const
{
    if (index.column() != 3 && index.column() != 4) {
        QStyledItemDelegate::setEditorData(editor, index);
        return;
    }

    QComboBox *comboBox = static_cast<QComboBox*>(editor);

    QString currentText = index.data(Qt::DisplayRole).toString();
    int cbIndex = comboBox->findText(currentText);

    if (cbIndex >= 0) {
        comboBox->setCurrentIndex(cbIndex);
    }

    comboBox->showPopup();
}

void ComboBoxDelegate::setModelData(QWidget *editor, QAbstractItemModel *model,
                                    const QModelIndex &index) const
{
    if (index.column() != 3 && index.column() != 4) {
        QStyledItemDelegate::setModelData(editor, model, index);
        return;
    }

    QComboBox *comboBox = static_cast<QComboBox*>(editor);
    int value = comboBox->currentData().toInt();

    if (index.column() == 3) {
        model->setData(index, value, TaskModel::PriorityRole);
    } else if (index.column() == 4) {
        model->setData(index, value, TaskModel::StatusRole);
    }
}

void ComboBoxDelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option,
                                            const QModelIndex &index) const
{
    Q_UNUSED(index);
    editor->setGeometry(option.rect);
}
</file>

<file path="widgets/statuswidget.cpp">
#include "statuswidget.h"
#include <QHBoxLayout>
#include <QPushButton>
#include <QButtonGroup>
#include <QDebug>
#include <QColor>

StatusWidget::StatusWidget(QWidget *parent)
    : QWidget(parent)
    , m_buttonGroup(new QButtonGroup(this))
{
    setupUI();
}

void StatusWidget::setupUI()
{
    QHBoxLayout *layout = new QHBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->setSpacing(5);

    // 创建四个状态按钮
    QStringList statusTexts = {"待办", "进行中", "已完成", "已延期"};

    for (int i = 0; i < 4; ++i) {
        QPushButton *button = new QPushButton(statusTexts[i], this);
        button->setCheckable(true);

        // 设置固定大小
        button->setFixedSize(80, 32);
        button->setObjectName(QString("statusBtn_%1").arg(i));

        m_buttons[i] = button;
        m_buttonGroup->addButton(button, i);
        layout->addWidget(button);
    }

    // 默认选择"待办"状态
    m_buttons[0]->setChecked(true);

    connect(m_buttonGroup, &QButtonGroup::idClicked,
            this, &StatusWidget::onButtonClicked);
}

int StatusWidget::getStatus() const
{
    return m_buttonGroup->checkedId();
}

void StatusWidget::setStatus(int status)
{
    if (status >= 0 && status < 4) {
        m_buttons[status]->setChecked(true);
    }
}

QString StatusWidget::getStatusText() const
{
    return getStatusText(getStatus());
}

QColor StatusWidget::getStatusColor() const
{
    return getStatusColor(getStatus());
}

void StatusWidget::onButtonClicked(int id)
{
    emit statusChanged(id);
}

QMap<int, QString> StatusWidget::getStatusOptions()
{
    return {
        {0, "待办"},
        {1, "进行中"},
        {2, "已完成"},
        {3, "已延期"}
    };
}

QString StatusWidget::getStatusText(int status)
{
    switch (status) {
    case 0: return "待办";
    case 1: return "进行中";
    case 2: return "已完成";
    case 3: return "已延期";
    default: return "未知";
    }
}

QColor StatusWidget::getStatusColor(int status)
{
    switch (status) {
    case 0: return QColor("#2196F3"); // 蓝色
    case 1: return QColor("#FF9800"); // 橙色
    case 2: return QColor("#4CAF50"); // 绿色
    case 3: return QColor("#F44336"); // 红色
    default: return QColor("#657896"); // 主题色
    }
}
</file>

<file path="dialogs/inspirationdialog.cpp">
#include "inspirationdialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QTextEdit>
#include <QLineEdit>
#include <QPushButton>
#include <QDialogButtonBox>
#include <QMessageBox>

InspirationDialog::InspirationDialog(QWidget *parent)
    : QDialog(parent), m_id(-1)
{
    setupUI();
    setWindowTitle("记录灵感");
}

InspirationDialog::InspirationDialog(const QVariantMap &data, QWidget *parent)
    : QDialog(parent), m_id(data.value("id", -1).toInt())
{
    setupUI();
    setWindowTitle("编辑灵感");
    populateData(data);
}

void InspirationDialog::setupUI()
{
    resize(400, 280);

    setWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint);

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->setSpacing(10);
    layout->setContentsMargins(15, 15, 15, 15);

    QLabel *tipLabel = new QLabel("捕捉当下的想法...", this);
    tipLabel->setStyleSheet("color: #888888; font-style: italic;");
    layout->addWidget(tipLabel);

    m_contentEdit = new QTextEdit(this);
    m_contentEdit->setPlaceholderText("在这里输入灵感内容...");
    m_contentEdit->setObjectName("inspirationContentEdit");
    layout->addWidget(m_contentEdit, 1);

    QHBoxLayout *tagLayout = new QHBoxLayout();
    QLabel *tagIcon = new QLabel("🏷️", this);
    m_tagsEdit = new QLineEdit(this);
    m_tagsEdit->setPlaceholderText("标签(每个标签最长6字，逗号分隔)");
    m_tagsEdit->setObjectName("inspirationTagEdit");

    tagLayout->addWidget(tagIcon);
    tagLayout->addWidget(m_tagsEdit);
    layout->addLayout(tagLayout);

    QHBoxLayout *btnLayout = new QHBoxLayout();
    btnLayout->addStretch();

    QPushButton *cancelBtn = new QPushButton("取消", this);
    QPushButton *saveBtn = new QPushButton("保存", this);
    saveBtn->setObjectName("saveInspirationBtn");
    saveBtn->setDefault(true);

    connect(cancelBtn, &QPushButton::clicked, this, &QDialog::reject);
    connect(saveBtn, &QPushButton::clicked, this, &InspirationDialog::onSave);

    btnLayout->addWidget(cancelBtn);
    btnLayout->addWidget(saveBtn);
    layout->addLayout(btnLayout);
}

void InspirationDialog::populateData(const QVariantMap &data)
{
    m_contentEdit->setText(data.value("content").toString());
    m_tagsEdit->setText(data.value("tags").toString());
}

QVariantMap InspirationDialog::getData() const
{
    QVariantMap data;
    if (m_id != -1) {
        data["id"] = m_id;
    }
    data["content"] = m_contentEdit->toPlainText().trimmed();
    data["tags"] = m_tagsEdit->text().trimmed();
    return data;
}

void InspirationDialog::onSave()
{
    if (m_contentEdit->toPlainText().trimmed().isEmpty()) {
        QMessageBox::warning(this, "提示", "内容不能为空");
        return;
    }

    QString tagsText = m_tagsEdit->text();
    tagsText.replace("，", ",");

    QStringList rawTags = tagsText.split(",", Qt::SkipEmptyParts);
    QStringList validTags;
    QSet<QString> seenTags;

    for (const QString &t : rawTags) {
        QString tag = t.trimmed();
        if (tag.isEmpty()) continue;

        if (tag.length() > 6) {
            QMessageBox::warning(this, "格式错误", QString("标签 '%1' 超过6个字限制").arg(tag));
            return;
        }

        if (!seenTags.contains(tag)) {
            validTags.append(tag);
            seenTags.insert(tag);
        }
    }

    m_tagsEdit->setText(validTags.join(","));

    accept();
}
</file>

<file path="dialogs/recyclebindialog.cpp">
#include "recyclebindialog.h"
#include "ui_recyclebindialog.h"
#include "models/taskmodel.h"
#include <QMessageBox>
#include <QHeaderView>
#include <QDebug>

RecycleBinDialog::RecycleBinDialog(QWidget *parent)
    : QDialog(parent)
    , ui(new Ui::RecycleBinDialog)
    , taskModel(nullptr)
{
    ui->setupUi(this);
    setWindowTitle("回收站");
    setupUI();
    setupConnections();
    setupTable();
}

RecycleBinDialog::~RecycleBinDialog()
{
    delete ui;
}

void RecycleBinDialog::setupUI()
{
    setModal(true);
    setWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint);
    resize(900, 600);

    ui->tableWidget->setSelectionBehavior(QAbstractItemView::SelectRows);
    ui->tableWidget->setSelectionMode(QAbstractItemView::SingleSelection);
    ui->tableWidget->setAlternatingRowColors(true);
    ui->tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers);
    ui->tableWidget->setSortingEnabled(true);
    ui->tableWidget->setShowGrid(true);
    ui->tableWidget->setGridStyle(Qt::SolidLine);

    QHeaderView *horizontalHeader = ui->tableWidget->horizontalHeader();
    horizontalHeader->setStretchLastSection(true);
    horizontalHeader->setSectionResizeMode(QHeaderView::Interactive);
    horizontalHeader->setDefaultAlignment(Qt::AlignCenter);
    horizontalHeader->setMinimumHeight(40);

    ui->tableWidget->setColumnCount(8);

    ui->tableWidget->setColumnWidth(0, 40);
    ui->tableWidget->setColumnWidth(1, 200);
    ui->tableWidget->setColumnWidth(2, 80);
    ui->tableWidget->setColumnWidth(3, 65);
    ui->tableWidget->setColumnWidth(4, 65);
    ui->tableWidget->setColumnWidth(5, 130);
    ui->tableWidget->setColumnWidth(6, 130);
    ui->tableWidget->setColumnWidth(7, 130);

    QStringList headers = {"ID", "标题", "分类", "优先级", "状态", "删除时间", "提醒时间", "创建时间"};
    ui->tableWidget->setHorizontalHeaderLabels(headers);

    ui->tableWidget->verticalHeader()->setVisible(false);
    ui->tableWidget->verticalHeader()->setDefaultSectionSize(35);
    ui->tableWidget->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    ui->tableWidget->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
}

void RecycleBinDialog::setupConnections()
{
    connect(ui->restoreButton, &QPushButton::clicked, this, &RecycleBinDialog::onRestoreClicked);
    connect(ui->deletePermanentlyButton, &QPushButton::clicked, this, &RecycleBinDialog::onDeletePermanentlyClicked);
    connect(ui->clearAllButton, &QPushButton::clicked, this, &RecycleBinDialog::onClearAllClicked);
    connect(ui->refreshButton, &QPushButton::clicked, this, &RecycleBinDialog::onRefreshClicked);
    connect(ui->closeButton, &QPushButton::clicked, this, &RecycleBinDialog::onCloseClicked);

    connect(ui->tableWidget, &QTableWidget::itemSelectionChanged,
            this, &RecycleBinDialog::updateButtonStates);
}

void RecycleBinDialog::setupTable()
{
    ui->tableWidget->setRowCount(0);
}

void RecycleBinDialog::setTaskModel(TaskModel *model)
{
    taskModel = model;
    if (taskModel) {
        refreshDeletedTasks();

        connect(taskModel, &TaskModel::taskRestored, this, [this](int taskId) {
            Q_UNUSED(taskId);
            refreshDeletedTasks();
        });

        connect(taskModel, &TaskModel::taskPermanentlyDeleted, this, [this](int taskId) {
            Q_UNUSED(taskId);
            refreshDeletedTasks();
        });
    }
}

void RecycleBinDialog::refreshDeletedTasks()
{
    qDebug() << "开始刷新回收站数据...";

    if (!taskModel) {
        qDebug() << "错误: taskModel 为空";
        ui->statusLabel->setText("错误: 任务模型未初始化");
        return;
    }

    deletedTasks = taskModel->getDeletedTasks();
    qDebug() << "获取到" << deletedTasks.size() << "个已删除任务";

    ui->tableWidget->setRowCount(0);

    if (deletedTasks.isEmpty()) {
        ui->tableWidget->setRowCount(0);
        ui->statusLabel->setText("回收站为空");
        updateButtonStates();
        return;
    }

    ui->tableWidget->setRowCount(deletedTasks.size());

    int row = 0;
    for (const QVariantMap &task : deletedTasks) {
        qDebug() << "处理第" << row << "行: ID=" << task["id"].toInt()
            << ", 标题=" << task["title"].toString();

        try {
            QTableWidgetItem *idItem = new QTableWidgetItem(QString::number(task["id"].toInt()));
            idItem->setTextAlignment(Qt::AlignCenter);
            idItem->setData(Qt::UserRole, task["id"]);
            ui->tableWidget->setItem(row, 0, idItem);

            QString title = task["title"].toString();
            QTableWidgetItem *titleItem = new QTableWidgetItem(title);
            QString description = task["description"].toString();
            if (!description.isEmpty()) {
                titleItem->setToolTip(description);
            }
            titleItem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem(row, 1, titleItem);

            QString categoryName = task["category_name"].toString();
            QTableWidgetItem *categoryItem = new QTableWidgetItem(categoryName.isEmpty() ? "未分类" : categoryName);
            categoryItem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem(row, 2, categoryItem);

            int priority = task["priority"].toInt();
            QString priorityText;
            switch (priority) {
            case 0: priorityText = "紧急"; break;
            case 1: priorityText = "重要"; break;
            case 2: priorityText = "普通"; break;
            case 3: priorityText = "不急"; break;
            default: priorityText = "未知";
            }
            QTableWidgetItem *priorityItem = new QTableWidgetItem(priorityText);
            priorityItem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem(row, 3, priorityItem);

            int status = task["status"].toInt();
            QString statusText;
            switch (status) {
            case 0: statusText = "待办"; break;
            case 1: statusText = "进行中"; break;
            case 2: statusText = "已完成"; break;
            case 3: statusText = "已延期"; break;
            default: statusText = "未知";
            }
            QTableWidgetItem *statusItem = new QTableWidgetItem(statusText);
            statusItem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem(row, 4, statusItem);

            QDateTime deletedTime = task["updated_at"].toDateTime();
            QTableWidgetItem *deletedItem = new QTableWidgetItem(
                deletedTime.isValid() ? deletedTime.toString("yyyy-MM-dd HH:mm") : "未知时间");
            deletedItem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem(row, 5, deletedItem);

            QDateTime remindTime = task["remind_time"].toDateTime();
            QTableWidgetItem *remindItem = new QTableWidgetItem(
                remindTime.isValid() ? remindTime.toString("yyyy-MM-dd HH:mm") : "-");
            remindItem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem(row, 6, remindItem);

            QDateTime createdTime = task["created_at"].toDateTime();
            QTableWidgetItem *createdItem = new QTableWidgetItem(
                createdTime.isValid() ? createdTime.toString("yyyy-MM-dd HH:mm") : "未知时间");
            createdItem->setTextAlignment(Qt::AlignCenter);
            ui->tableWidget->setItem(row, 7, createdItem);

            row++;

        } catch (const std::exception &e) {
            qDebug() << "处理任务数据时出错:" << e.what();
            continue;
        }
    }

    ui->statusLabel->setText(QString("共 %1 个已删除任务").arg(deletedTasks.size()));

    updateButtonStates();

    ui->tableWidget->viewport()->update();
    qDebug() << "回收站刷新完成，显示" << row << "行数据";
}

void RecycleBinDialog::onRestoreClicked()
{
    int taskId = getSelectedTaskId();
    if (taskId == -1) return;

    showConfirmationDialog("恢复任务", "确定要恢复选中的任务吗？", [this, taskId]() {
        if (taskModel && taskModel->restoreTask(taskId)) {
            QMessageBox::information(this, "成功", "任务恢复成功！");
        } else {
            QMessageBox::warning(this, "错误", "任务恢复失败");
        }
    });
}

void RecycleBinDialog::onDeletePermanentlyClicked()
{
    int taskId = getSelectedTaskId();
    if (taskId == -1) return;

    QString taskTitle;
    for (const QVariantMap &task : deletedTasks) {
        if (task["id"].toInt() == taskId) {
            taskTitle = task["title"].toString();
            break;
        }
    }

    showConfirmationDialog("永久删除",
                           QString("确定要永久删除任务 '%1' 吗？\n此操作不可撤销！").arg(taskTitle),
                           [this, taskId]() {
                               if (taskModel && taskModel->permanentDeleteTask(taskId)) {
                                   QMessageBox::information(this, "成功", "任务已永久删除！");
                               } else {
                                   QMessageBox::warning(this, "错误", "删除失败");
                               }
                           });
}

void RecycleBinDialog::onClearAllClicked()
{
    if (deletedTasks.isEmpty()) return;

    showConfirmationDialog("清空回收站",
                           QString("确定要清空回收站吗？\n这将永久删除 %1 个任务，此操作不可撤销！").arg(deletedTasks.size()),
                           [this]() {
                               int successCount = 0;
                               int failCount = 0;

                               for (const QVariantMap &task : deletedTasks) {
                                   int taskId = task["id"].toInt();
                                   if (taskModel && taskModel->permanentDeleteTask(taskId)) {
                                       successCount++;
                                   } else {
                                       failCount++;
                                   }
                               }

                               if (failCount == 0) {
                                   QMessageBox::information(this, "成功",
                                                            QString("已成功删除 %1 个任务").arg(successCount));
                               } else {
                                   QMessageBox::warning(this, "完成",
                                                        QString("删除完成：成功 %1 个，失败 %2 个").arg(successCount).arg(failCount));
                               }
                           });
}

void RecycleBinDialog::onRefreshClicked()
{
    refreshDeletedTasks();
}

void RecycleBinDialog::onCloseClicked()
{
    accept();
}

void RecycleBinDialog::updateButtonStates()
{
    bool hasSelection = ui->tableWidget->selectionModel()->hasSelection();
    ui->restoreButton->setEnabled(hasSelection);
    ui->deletePermanentlyButton->setEnabled(hasSelection);
    ui->clearAllButton->setEnabled(!deletedTasks.isEmpty());
}

int RecycleBinDialog::getSelectedTaskId() const
{
    QList<QTableWidgetItem*> selectedItems = ui->tableWidget->selectedItems();
    if (selectedItems.isEmpty()) return -1;

    int row = selectedItems.first()->row();
    QTableWidgetItem *idItem = ui->tableWidget->item(row, 0);
    if (idItem) {
        return idItem->data(Qt::UserRole).toInt();
    }

    return -1;
}

void RecycleBinDialog::showConfirmationDialog(const QString &title, const QString &message,
                                              std::function<void()> onConfirmed)
{
    QMessageBox msgBox(this);
    msgBox.setWindowTitle(title);
    msgBox.setText(message);
    msgBox.setIcon(QMessageBox::Question);
    msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No);
    msgBox.setDefaultButton(QMessageBox::No);

    if (msgBox.exec() == QMessageBox::Yes) {
        onConfirmed();
    }
}
</file>

<file path="dialogs/tagmanagerdialog.cpp">
#include "tagmanagerdialog.h"
#include "ui_tagmanagerdialog.h"
#include "database/database.h"
#include "widgets/tagwidget.h"
#include <QMessageBox>
#include <QDebug>

TagManagerDialog::TagManagerDialog(QWidget *parent)
    : QDialog(parent)
    , ui(new Ui::TagManagerDialog)
{
    ui->setupUi(this);
    setupUI();
    setupConnections();
    refreshTags();
}

TagManagerDialog::~TagManagerDialog()
{
    delete ui;
}

void TagManagerDialog::setupUI()
{
    ui->splitter->setStretchFactor(0, 12);
    ui->splitter->setStretchFactor(1, 23);

    ui->taskTableWidget->setColumnWidth(0, 50);
    ui->taskTableWidget->setColumnWidth(1, 280);
}

void TagManagerDialog::setupConnections()
{
    connect(ui->tagListWidget, &QListWidget::itemClicked, this, &TagManagerDialog::onTagSelected);
    connect(ui->addTagButton, &QPushButton::clicked, this, &TagManagerDialog::onAddTagClicked);
    connect(ui->deleteTagButton, &QPushButton::clicked, this, &TagManagerDialog::onDeleteTagClicked);
    connect(ui->removeRelationButton, &QPushButton::clicked, this, &TagManagerDialog::onRemoveRelationClicked);
}

void TagManagerDialog::refreshTags()
{
    ui->tagListWidget->clear();
    ui->taskTableWidget->setRowCount(0);
    allTags = Database::instance().getAllTags();

    for (const QVariantMap &tag : allTags) {
        QListWidgetItem *item = new QListWidgetItem(tag["name"].toString());
        item->setData(Qt::UserRole, tag["id"]);
        item->setData(Qt::UserRole + 1, tag["color"]);

        QPixmap pixmap(16, 16);
        pixmap.fill(QColor(tag["color"].toString()));
        item->setIcon(QIcon(pixmap));

        ui->tagListWidget->addItem(item);
    }
}

void TagManagerDialog::onTagSelected(QListWidgetItem *item)
{
    if (!item) return;

    int tagId = item->data(Qt::UserRole).toInt();
    QList<QVariantMap> tasks = Database::instance().getTasksByTagId(tagId);

    ui->taskTableWidget->setRowCount(tasks.size());
    for (int i = 0; i < tasks.size(); ++i) {
        const QVariantMap &task = tasks[i];

        QTableWidgetItem *idItem = new QTableWidgetItem(QString::number(task["id"].toInt()));
        idItem->setTextAlignment(Qt::AlignCenter);
        ui->taskTableWidget->setItem(i, 0, idItem);

        QString title = task["title"].toString();
        QTableWidgetItem *titleItem = new QTableWidgetItem(title);
        titleItem->setTextAlignment(Qt::AlignCenter);
        ui->taskTableWidget->setItem(i, 1, titleItem);

        QString categoryName = task["category_name"].toString();
        QTableWidgetItem *categoryItem = new QTableWidgetItem(categoryName.isEmpty() ? "未分类" : categoryName);
        categoryItem->setTextAlignment(Qt::AlignCenter);
        ui->taskTableWidget->setItem(i, 2, categoryItem);
    }
}

void TagManagerDialog::onAddTagClicked()
{
    QString name = ui->tagNameInput->text().trimmed();
    if (name.isEmpty()) return;

    if (name.length() > 6) {
        QMessageBox::warning(this, "格式错误", "标签名称请限制在6个字以内");
        return;
    }

    QString color = TagWidget::generateColor(name);
    if (Database::instance().addTag(name, color)) {
        ui->tagNameInput->clear();
        refreshTags();
    } else {
        QMessageBox::warning(this, "错误", "添加标签失败，可能标签已存在");
    }
}

void TagManagerDialog::onDeleteTagClicked()
{
    QListWidgetItem *item = ui->tagListWidget->currentItem();
    if (!item) {
        QMessageBox::warning(this, "提示", "请先选择一个标签");
        return;
    }

    int tagId = item->data(Qt::UserRole).toInt();
    QString tagName = item->text();

    QList<QVariantMap> tasks = Database::instance().getTasksByTagId(tagId);

    if (tasks.isEmpty()) {
        if (QMessageBox::question(this, "确认删除", "确定要删除标签 '" + tagName + "' 吗？") == QMessageBox::Yes) {
            Database::instance().deleteTag(tagId);
            refreshTags();
        }
    } else {
        QString msg = QString("标签 '%1' 已关联 %2 个任务：\n\n").arg(tagName).arg(tasks.size());
        int count = 0;
        for (const QVariantMap &task : tasks) {
            if (count++ >= 5) {
                msg += "...等";
                break;
            }
            msg += QString("- [%1] %2\n").arg(task["id"].toString()).arg(task["title"].toString());
        }
        msg += "\n删除标签将自动解除这些关联。确定要继续吗？";

        if (QMessageBox::warning(this, "关联警告", msg, QMessageBox::Yes | QMessageBox::No) == QMessageBox::Yes) {
            Database::instance().deleteTag(tagId);
            refreshTags();
        }
    }
}

void TagManagerDialog::onRemoveRelationClicked()
{
    QListWidgetItem *tagItem = ui->tagListWidget->currentItem();
    if (!tagItem) {
        QMessageBox::warning(this, "提示", "请先在左侧选择一个标签");
        return;
    }
    int tagId = tagItem->data(Qt::UserRole).toInt();

    int currentRow = ui->taskTableWidget->currentRow();
    if (currentRow < 0) {
        QMessageBox::warning(this, "提示", "请在右侧列表中选择要解除关联的任务");
        return;
    }

    QTableWidgetItem *idItem = ui->taskTableWidget->item(currentRow, 0);
    if (!idItem) return;
    int taskId = idItem->text().toInt();
    QString taskTitle = ui->taskTableWidget->item(currentRow, 1)->text();

    QString msg = QString("确定要移除任务 '%1' 的 '%2' 标签吗？").arg(taskTitle).arg(tagItem->text());
    if (QMessageBox::question(this, "确认解除", msg) == QMessageBox::Yes) {
        if (Database::instance().removeTaskTagRelation(taskId, tagId)) {
            onTagSelected(tagItem);
        } else {
            QMessageBox::warning(this, "错误", "解除关联失败");
        }
    }
}
</file>

<file path="main.cpp">
#include "mainwindow.h"
#include <QApplication>
#include <QFile>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    a.setWindowIcon(QIcon(":/icons/tray_icon.png"));
    a.setApplicationName("个人工作与任务管理系统");
    a.setApplicationVersion("1.0.0");
    a.setOrganizationName("谢静蕾");

    MainWindow w;
    w.show();

    return a.exec();
}
</file>

<file path="models/taskitem.cpp">
#include "taskitem.h"
#include <QColor>

QVariantMap TaskItem::toVariantMap() const {
    QVariantMap map;
    map["id"] = id;
    map["title"] = title;
    map["description"] = description;
    map["category_id"] = categoryId;
    map["category_name"] = categoryName;
    map["category_color"] = categoryColor;
    map["priority"] = priority;
    map["status"] = status;
    map["start_time"] = startTime;
    map["deadline"] = deadline;
    map["remind_time"] = remindTime;
    map["is_reminded"] = isReminded;
    map["is_deleted"] = isDeleted;
    map["created_at"] = createdAt;
    map["updated_at"] = updatedAt;
    map["completed_at"] = completedAt;

    QVariantList tagIdList, tagNameList, tagColorList;
    for (int tagId : tagIds) tagIdList.append(tagId);
    for (const QString &tagName : tagNames) tagNameList.append(tagName);
    for (const QString &tagColor : tagColors) tagColorList.append(tagColor);

    map["tag_ids"] = tagIdList;
    map["tag_names"] = tagNameList;
    map["tag_colors"] = tagColorList;

    return map;
}

TaskItem TaskItem::fromVariantMap(const QVariantMap &data) {
    TaskItem item;
    item.id = data["id"].toInt();
    item.title = data["title"].toString();
    item.description = data["description"].toString();
    item.categoryId = data["category_id"].toInt();
    item.categoryName = data["category_name"].toString();
    item.categoryColor = data["category_color"].toString();
    item.priority = data["priority"].toInt();
    item.status = data["status"].toInt();
    item.startTime = data["start_time"].toDateTime();
    item.deadline = data["deadline"].toDateTime();
    item.remindTime = data["remind_time"].toDateTime();
    item.isReminded = data["is_reminded"].toBool();
    item.isDeleted = data["is_deleted"].toBool();
    item.createdAt = data["created_at"].toDateTime();
    item.updatedAt = data["updated_at"].toDateTime();
    item.completedAt = data["completed_at"].toDateTime();

    QVariantList tagIds = data["tag_ids"].toList();
    QVariantList tagNames = data["tag_names"].toList();
    QVariantList tagColors = data["tag_colors"].toList();

    for (const QVariant &tagId : tagIds) item.tagIds.append(tagId.toInt());
    for (const QVariant &tagName : tagNames) item.tagNames.append(tagName.toString());
    for (const QVariant &tagColor : tagColors) item.tagColors.append(tagColor.toString());

    return item;
}

QString TaskItem::priorityText() const {
    switch (priority) {
    case 0: return "紧急";
    case 1: return "重要";
    case 2: return "普通";
    case 3: return "不急";
    default: return "未知";
    }
}

QString TaskItem::statusText() const {
    switch (status) {
    case 0: return "待办";
    case 1: return "进行中";
    case 2: return "已完成";
    case 3: return "已延期";
    default: return "未知";
    }
}

QColor TaskItem::priorityColor() const {
    switch (priority) {
    case 0: return QColor("#C96A6A");
    case 1: return QColor("#D69E68");
    case 2: return QColor("#7FA882");
    case 3: return QColor("#8C949E");
    default: return QColor("#7696B3");
    }
}

QColor TaskItem::statusColor() const {
    switch (status) {
    case 0: return QColor("#7696B3");
    case 1: return QColor("#D69E68");
    case 2: return QColor("#7FA882");
    case 3: return QColor("#C96A6A");
    default: return QColor("#8C949E");
    }
}

bool TaskItem::isOverdue() const {
    if (status == 2) return false;
    if (!deadline.isValid()) return false;
    return deadline < QDateTime::currentDateTime();
}
</file>

<file path="resources/resources.qrc">
<RCC>
    <qresource prefix="/">
        <file>icons/add_icon.png</file>
        <file>icons/delete_icon.png</file>
        <file>icons/edit_icon.png</file>
        <file>icons/export_icon.png</file>
        <file>icons/recycle_icon.png</file>
        <file>icons/refresh_icon.png</file>
        <file>icons/tray_icon.png</file>
        <file>styles/kanban.qss</file>
        <file>styles/mainwindow.qss</file>
        <file>styles/widget.qss</file>
        <file>styles/calendar.qss</file>
        <file>styles/dialog.qss</file>
        <file>icons/left_arrow.png</file>
        <file>icons/right_arrow.png</file>
        <file>styles/statistic.qss</file>
    </qresource>
</RCC>
</file>

<file path="views/inspirationview.h">
#ifndef INSPIRATIONVIEW_H
#define INSPIRATIONVIEW_H

#include <QWidget>
#include <QStyledItemDelegate>
#include <QListWidget>
#include <QStackedWidget>
#include <QButtonGroup>
#include <QDate>
#include <QSpinBox>
#include <QCheckBox>
#include <QComboBox>

class InspirationModel;
class QTableView;
class QLineEdit;
class QSpinBox;
class QCheckBox;

class InspirationGridDelegate : public QStyledItemDelegate
{
    Q_OBJECT
public:
    explicit InspirationGridDelegate(QObject *parent = nullptr);

    void paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const override;
    QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const override;
};

class CalendarView;

class InspirationView : public QWidget
{
    Q_OBJECT

public:
    explicit InspirationView(QWidget *parent = nullptr);
    void setModel(InspirationModel *model);
    bool restoreInspiration(int id);
    bool permanentDeleteInspiration(int id);
    QList<QVariantMap> getDeletedInspirations() const;
    bool emptyRecycleBin();
    bool renameTag(const QString &oldName, const QString &newName);
    bool removeTagFromAll(const QString &tagName);

public slots:
    void refresh();
    void setTaskModel(class TaskModel *model);

signals:
    void showRecycleBinRequested();
    void showTagManagerRequested();
    void showInspirationsRequested(const QDate &date);
    void showTasksRequested(const QDate &date);

private slots:
    void onSearchTextChanged(const QString &text);
    void onTagSearchClicked();
    void onDoubleClicked(const QModelIndex &index);
    void onAddClicked();
    void onEditClicked();
    void onDeleteClicked();

private:
    InspirationModel *m_model;

    QStackedWidget *m_viewStack;
    QTableView *m_tableView;
    QListWidget *m_gridView;
    CalendarView *m_calendarView;
    QLineEdit *m_searchEdit;
    QStringList m_filterTags;
    bool m_filterMatchAll;
    void setupUI();
    void refreshGridView();
    void applyFilters();
    QWidget *m_leftBottomContainer;
    QCheckBox *m_dateFilterCheck;
    QSpinBox *m_yearSpin;
    QSpinBox *m_monthSpin;
    QComboBox *m_monthFilterCombo;
};

#endif // INSPIRATIONVIEW_H
</file>

<file path="views/tasktableview.cpp">
#include "tasktableview.h"
#include "widgets/comboboxdelegate.h"
#include "models/taskmodel.h"
#include <QHeaderView>
#include <QAbstractProxyModel>
#include <QDebug>

TaskTableView::TaskTableView(QWidget *parent)
    : QTableView(parent)
{
    setupUI();
    connect(this, &QTableView::doubleClicked, this, &TaskTableView::onDoubleClicked);
}

void TaskTableView::setupUI()
{
    setSelectionBehavior(QAbstractItemView::SelectRows);
    setSelectionMode(QAbstractItemView::SingleSelection);
    setAlternatingRowColors(true);
    setSortingEnabled(true);
    setEditTriggers(QAbstractItemView::AllEditTriggers);
    setFrameShape(QFrame::NoFrame);

    setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
    setHorizontalScrollMode(QAbstractItemView::ScrollPerPixel);

    verticalHeader()->setVisible(false);
    verticalHeader()->setDefaultSectionSize(35);

    horizontalHeader()->setStretchLastSection(true);
    horizontalHeader()->setDefaultAlignment(Qt::AlignCenter);
    horizontalHeader()->setSectionResizeMode(QHeaderView::Interactive);
    horizontalHeader()->setHighlightSections(false);
}

void TaskTableView::setModel(QAbstractItemModel *model)
{
    QTableView::setModel(model);

    ComboBoxDelegate *delegate = new ComboBoxDelegate(this);
    setItemDelegateForColumn(3, delegate);
    setItemDelegateForColumn(4, delegate);

    setColumnWidth(0, 50);
    setColumnWidth(1, 240);
    setColumnWidth(2, 100);
    setColumnWidth(3, 90);
    setColumnWidth(4, 90);
    setColumnWidth(5, 160);
    setColumnWidth(6, 160);
    setColumnWidth(7, 160);

    sortByColumn(5, Qt::AscendingOrder);
}

void TaskTableView::onDoubleClicked(const QModelIndex &index)
{
    if (!index.isValid()) return;

    if (index.column() == 3 || index.column() == 4) {
        return;
    }

    QModelIndex sourceIndex = index;
    if (QAbstractProxyModel *proxy = qobject_cast<QAbstractProxyModel*>(model())) {
        sourceIndex = proxy->mapToSource(index);
    }

    int taskId = sourceIndex.data(TaskModel::IdRole).toInt();
    if (taskId > 0) {
        emit editTaskRequested(taskId);
    }
}
</file>

<file path="views/tasktableview.h">
#ifndef TASKTABLEVIEW_H
#define TASKTABLEVIEW_H

#include <QTableView>

class TaskTableView : public QTableView
{
    Q_OBJECT

public:
    explicit TaskTableView(QWidget *parent = nullptr);

    void setModel(QAbstractItemModel *model) override;

signals:
    void editTaskRequested(int taskId);

private slots:
    void onDoubleClicked(const QModelIndex &index);

private:
    void setupUI();
};

#endif // TASKTABLEVIEW_H
</file>

<file path="widgets/prioritywidget.cpp">
#include "prioritywidget.h"
#include <QHBoxLayout>
#include <QPushButton>
#include <QButtonGroup>
#include <QDebug>
#include <QColor>

PriorityWidget::PriorityWidget(QWidget *parent)
    : QWidget(parent)
    , m_buttonGroup(new QButtonGroup(this))
{
    setupUI();
}

void PriorityWidget::setupUI()
{
    QHBoxLayout *layout = new QHBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->setSpacing(5);

    QStringList priorityTexts = {"紧急", "重要", "普通", "不急"};

    for (int i = 0; i < 4; ++i) {
        QPushButton *button = new QPushButton(priorityTexts[i], this);
        button->setCheckable(true);
        button->setFixedSize(70, 32);
        button->setObjectName(QString("priorityBtn_%1").arg(i));

        m_buttons[i] = button;
        m_buttonGroup->addButton(button, i);
        layout->addWidget(button);
    }

    m_buttons[2]->setChecked(true);

    connect(m_buttonGroup, &QButtonGroup::idClicked,
            this, &PriorityWidget::onButtonClicked);
}

int PriorityWidget::getPriority() const
{
    return m_buttonGroup->checkedId();
}

void PriorityWidget::setPriority(int priority)
{
    if (priority >= 0 && priority < 4) {
        m_buttons[priority]->setChecked(true);
    }
}

QString PriorityWidget::getPriorityText() const
{
    return getPriorityText(getPriority());
}

QColor PriorityWidget::getPriorityColor() const
{
    return getPriorityColor(getPriority());
}

void PriorityWidget::onButtonClicked(int id)
{
    emit priorityChanged(id);
}

QMap<int, QString> PriorityWidget::getPriorityOptions()
{
    return {
        {0, "紧急"},
        {1, "重要"},
        {2, "普通"},
        {3, "不急"}
    };
}

QString PriorityWidget::getPriorityText(int priority)
{
    switch (priority) {
    case 0: return "紧急";
    case 1: return "重要";
    case 2: return "普通";
    case 3: return "不急";
    default: return "未知";
    }
}

QColor PriorityWidget::getPriorityColor(int priority)
{
    switch (priority) {
    case 0: return QColor("#FF4444");
    case 1: return QColor("#FF9900");
    case 2: return QColor("#4CAF50");
    case 3: return QColor("#9E9E9E");
    default: return QColor("#657896");
    }
}
</file>

<file path="widgets/watermarkwidget.cpp">
#include "watermarkwidget.h"
#include <QPainter>
#include <QPaintEvent>
#include <QResizeEvent>
#include <QApplication>
#include <QScreen>
#include <QDebug>

WatermarkWidget::WatermarkWidget(const QString &text, QWidget *parent)
    : QWidget(parent), watermarkText(text)
{
    setAttribute(Qt::WA_TransparentForMouseEvents);

    setWindowFlags(windowFlags() | Qt::FramelessWindowHint);
    setAttribute(Qt::WA_TranslucentBackground);

    if (parent) {
        setGeometry(0, 0, parent->width(), parent->height());
    }
}

void WatermarkWidget::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);

    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing, true);
    painter.setRenderHint(QPainter::TextAntialiasing, true);

    QFont font("Microsoft YaHei", 16, QFont::Light);
    painter.setOpacity(0.15);
    painter.setPen(QColor("#657896"));
    painter.save();
    painter.translate(width() / 2, height() / 2);
    painter.rotate(-30);

    QFontMetrics fm(font);
    int textWidth = fm.horizontalAdvance(watermarkText);
    int textHeight = fm.height();
    int gridSize = qMax(textWidth, textHeight) + 100;

    for (int x = -width(); x < width() * 2; x += gridSize) {
        for (int y = -height(); y < height() * 2; y += gridSize) {
            painter.drawText(x, y, watermarkText);
        }
    }

    painter.restore();
    painter.setOpacity(0.08);
    QFont smallFont("Microsoft YaHei", 10);
    painter.setFont(smallFont);

    painter.drawText(10, 20, watermarkText);
    painter.drawText(width() - fm.horizontalAdvance(watermarkText) - 10, 20, watermarkText);
    painter.drawText(10, height() - 10, watermarkText);
    painter.drawText(width() - fm.horizontalAdvance(watermarkText) - 10, height() - 10, watermarkText);
}

void WatermarkWidget::resizeEvent(QResizeEvent *event)
{
    QWidget::resizeEvent(event);
    update();
}
</file>

<file path="dialogs/taskdialog.h">
#ifndef TASKDIALOG_H
#define TASKDIALOG_H

#include <QDialog>
#include <QDateTime>
#include <QVariantMap>

namespace Ui {
class TaskDialog;
}

class PriorityWidget;
class StatusWidget;
class TagWidget;

class TaskDialog : public QDialog
{
    Q_OBJECT

public:
    explicit TaskDialog(QWidget *parent = nullptr);
    explicit TaskDialog(const QVariantMap &taskData, QWidget *parent = nullptr);
    ~TaskDialog();

    QVariantMap getTaskData() const;
    bool isEditMode() const { return m_isEditMode; }
    int getTaskId() const { return m_taskId; }

    static QVariantMap createTask(const QVariantMap &initialData = QVariantMap(),
                                  QWidget *parent = nullptr);
    static QVariantMap editTask(const QVariantMap &taskData, QWidget *parent = nullptr);

protected:
    void showEvent(QShowEvent *event) override;
    bool eventFilter(QObject *obj, QEvent *event) override;

private slots:
    void onSaveClicked();
    void onCancelClicked();
    void onAddTagClicked();
    void loadCategories();
    void loadExistingTags();

private:
    Ui::TaskDialog *ui;
    bool m_isEditMode;
    int m_taskId;

    PriorityWidget *m_priorityWidget;
    StatusWidget *m_statusWidget;
    TagWidget *m_tagWidget;
    QWidget *m_existingTagsContainer;
    class QLabel *m_labelCreatedTime;
    class QLabel *m_labelCompletedTime;
    int m_originalStatus;
    QDateTime m_originalCompletedTime;
    QDateTime m_originalCreatedTime;
    void setupUI();
    void setupConnections();
    void initDateTimeEdits();
    void populateData(const QVariantMap &taskData);
    bool validateInput();
    QList<QVariantMap> getSelectedTags() const;
    void addExistingTagButton(const QString &name, const QString &color);
};

#endif // TASKDIALOG_H
</file>

<file path="models/inspirationmodel.cpp">
#include "inspirationmodel.h"
#include "database/database.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>
#include <QDate>

static QSqlDatabase getDbConnection()
{
    QSqlDatabase db = Database::instance().getDatabase();
    if (!db.isOpen()) {
        Database::instance().ensureConnected();
        db = Database::instance().getDatabase();
    }
    return db;
}

InspirationModel::InspirationModel(QObject *parent)
    : QAbstractTableModel(parent)
{
    db = Database::instance().getDatabase();
    refresh();
}

InspirationModel::~InspirationModel()
{
}

int InspirationModel::rowCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return inspirations.size();
}

int InspirationModel::columnCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return 3;
}

QVariant InspirationModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid() || index.row() >= inspirations.size())
        return QVariant();

    const InspirationItem &item = inspirations.at(index.row());

    switch (role) {
    case Qt::DisplayRole:
        switch (index.column()) {
        case 0: return item.createdAt.toString("yyyy-MM-dd HH:mm:ss");
        case 1: return item.preview();
        case 2: return item.tags;
        default: return QVariant();
        }

    case Qt::UserRole:
        return item.toVariantMap();

    case Qt::ToolTipRole:
        return QString("完整内容:\n%1\n\n标签: %2")
            .arg(item.content)
            .arg(item.tags);

    case Qt::TextAlignmentRole:
        if (index.column() == 1) return int(Qt::AlignLeft | Qt::AlignVCenter);
        return int(Qt::AlignCenter);

    default:
        return QVariant();
    }
}

QVariant InspirationModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (role != Qt::DisplayRole)
        return QVariant();

    if (orientation == Qt::Horizontal) {
        switch (section) {
        case 0: return "记录时间";
        case 1: return "内容预览";
        case 2: return "标签";
        default: return QVariant();
        }
    }

    return QVariant();
}

Qt::ItemFlags InspirationModel::flags(const QModelIndex &index) const
{
    if (!index.isValid())
        return Qt::NoItemFlags;

    return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

void InspirationModel::loadInspirations()
{
    beginResetModel();
    inspirations.clear();

    QSqlQuery query(db);
    query.prepare("SELECT * FROM inspirations WHERE is_deleted = 0 ORDER BY created_at DESC");

    if (!query.exec()) {
        qDebug() << "加载灵感记录失败:" << query.lastError().text();
        endResetModel();
        return;
    }

    while (query.next()) {
        InspirationItem item;
        item.id = query.value("id").toInt();
        item.content = query.value("content").toString();
        item.tags = query.value("tags").toString();
        item.createdAt = query.value("created_at").toDateTime();
        item.updatedAt = query.value("updated_at").toDateTime();

        inspirations.append(item);
    }

    endResetModel();
}

bool InspirationModel::addInspiration(const QString &content, const QString &tags)
{
    QSqlQuery query(db);
    query.prepare("INSERT INTO inspirations (content, tags, created_at, updated_at) "
                  "VALUES (?, ?, ?, ?)");

    QDateTime now = getCurrentTimestamp();
    query.addBindValue(content);
    query.addBindValue(tags);
    query.addBindValue(now);
    query.addBindValue(now);

    if (!query.exec()) {
        qDebug() << "添加灵感记录失败:" << query.lastError().text();
        return false;
    }

    int newId = query.lastInsertId().toInt();

    refresh();
    emit inspirationAdded(newId);

    return true;
}

bool InspirationModel::updateInspiration(int id, const QString &content, const QString &tags)
{
    QSqlQuery query(db);
    query.prepare("UPDATE inspirations SET content = ?, tags = ?, updated_at = ? WHERE id = ?");

    query.addBindValue(content);
    query.addBindValue(tags);
    query.addBindValue(getCurrentTimestamp());
    query.addBindValue(id);

    if (!query.exec()) {
        qDebug() << "更新灵感记录失败:" << query.lastError().text();
        return false;
    }

    refresh();
    emit inspirationUpdated(id);

    return true;
}


bool InspirationModel::deleteInspiration(int id)
{
    QSqlQuery query(db);
    query.prepare("UPDATE inspirations SET is_deleted = 1, updated_at = ? WHERE id = ?");
    query.addBindValue(getCurrentTimestamp());
    query.addBindValue(id);

    if (!query.exec()) {
        qDebug() << "删除灵感记录失败:" << query.lastError().text();
        return false;
    }

    refresh();
    emit inspirationDeleted(id);
    return true;
}

bool InspirationModel::deleteInspirations(const QList<int> &ids)
{
    if (ids.isEmpty()) return true;

    db.transaction();

    QSqlQuery query(db);
    query.prepare("DELETE FROM inspirations WHERE id = ?");

    for (int id : ids) {
        query.addBindValue(id);
        if (!query.exec()) {
            qDebug() << "批量删除灵感记录失败:" << query.lastError().text();
            db.rollback();
            return false;
        }
    }

    db.commit();

    refresh();

    return true;
}

QList<QVariantMap> InspirationModel::getAllInspirations() const
{
    QList<QVariantMap> result;

    QSqlQuery query(db);
    query.prepare("SELECT * FROM inspirations ORDER BY created_at DESC");

    if (query.exec()) {
        while (query.next()) {
            QVariantMap item;
            item["id"] = query.value("id").toInt();
            item["content"] = query.value("content").toString();
            item["tags"] = query.value("tags").toString();
            item["created_at"] = query.value("created_at").toDateTime();
            item["updated_at"] = query.value("updated_at").toDateTime();
            result.append(item);
        }
    }

    return result;
}

QList<QVariantMap> InspirationModel::getInspirationsByDate(const QDate &date) const
{
    QList<QVariantMap> result;

    QSqlQuery query(db);
    query.prepare("SELECT * FROM inspirations "
                  "WHERE DATE(created_at) = ? "
                  "ORDER BY created_at DESC");
    query.addBindValue(date.toString("yyyy-MM-dd"));

    if (query.exec()) {
        while (query.next()) {
            QVariantMap item;
            item["id"] = query.value("id").toInt();
            item["content"] = query.value("content").toString();
            item["tags"] = query.value("tags").toString();
            item["created_at"] = query.value("created_at").toDateTime();
            item["updated_at"] = query.value("updated_at").toDateTime();
            result.append(item);
        }
    }

    return result;
}

QList<QVariantMap> InspirationModel::getInspirationsByTag(const QString &tag) const
{
    QList<QVariantMap> result;

    QSqlQuery query(db);
    query.prepare("SELECT * FROM inspirations "
                  "WHERE tags LIKE ? "
                  "ORDER BY created_at DESC");
    query.addBindValue("%" + tag + "%");

    if (query.exec()) {
        while (query.next()) {
            QVariantMap item;
            item["id"] = query.value("id").toInt();
            item["content"] = query.value("content").toString();
            item["tags"] = query.value("tags").toString();
            item["created_at"] = query.value("created_at").toDateTime();
            item["updated_at"] = query.value("updated_at").toDateTime();
            result.append(item);
        }
    }

    return result;
}

QList<QVariantMap> InspirationModel::searchInspirations(const QString &keyword) const
{
    QList<QVariantMap> result;

    if (keyword.isEmpty()) {
        return getAllInspirations();
    }

    QSqlQuery query(db);
    query.prepare("SELECT * FROM inspirations "
                  "WHERE content LIKE ? OR tags LIKE ? "
                  "ORDER BY created_at DESC");
    QString searchPattern = "%" + keyword + "%";
    query.addBindValue(searchPattern);
    query.addBindValue(searchPattern);

    if (query.exec()) {
        while (query.next()) {
            QVariantMap item;
            item["id"] = query.value("id").toInt();
            item["content"] = query.value("content").toString();
            item["tags"] = query.value("tags").toString();
            item["created_at"] = query.value("created_at").toDateTime();
            item["updated_at"] = query.value("updated_at").toDateTime();
            result.append(item);
        }
    }

    return result;
}

int InspirationModel::getInspirationCount() const
{
    QSqlQuery query(db);
    query.prepare("SELECT COUNT(*) FROM inspirations");

    if (query.exec() && query.next()) {
        return query.value(0).toInt();
    }

    return 0;
}

QList<QDate> InspirationModel::getDatesWithInspirations() const
{
    QList<QDate> dates;

    QSqlQuery query(db);
    query.prepare("SELECT DISTINCT DATE(created_at) as date FROM inspirations ORDER BY date DESC");

    if (query.exec()) {
        while (query.next()) {
            dates.append(query.value("date").toDate());
        }
    }

    return dates;
}

QList<QDate> InspirationModel::getDatesWithInspirations(const QStringList &filterTags, bool matchAll) const
{
    if (filterTags.isEmpty()) {
        return getDatesWithInspirations();
    }

    QSet<QDate> dateSet;

    for (const InspirationItem &item : inspirations) {
        QStringList itemTags = item.tagList();
        bool match = true;

        if (matchAll) {
            for (const QString &filterTag : filterTags) {
                if (!itemTags.contains(filterTag, Qt::CaseInsensitive)) {
                    match = false;
                    break;
                }
            }
        } else {
            match = false;
            for (const QString &filterTag : filterTags) {
                if (itemTags.contains(filterTag, Qt::CaseInsensitive)) {
                    match = true;
                    break;
                }
            }
        }

        if (match) {
            dateSet.insert(item.createdAt.date());
        }
    }

    QList<QDate> result = dateSet.values();
    std::sort(result.begin(), result.end());
    return result;
}

QStringList InspirationModel::getAllTags() const
{
    QStringList allTags;
    QSet<QString> uniqueTags;

    QSqlQuery query(db);
    query.prepare("SELECT tags FROM inspirations WHERE tags IS NOT NULL AND tags != ''");

    if (query.exec()) {
        while (query.next()) {
            QString tags = query.value("tags").toString();
            QStringList tagList = tags.split(",", Qt::SkipEmptyParts);
            for (const QString &tag : tagList) {
                uniqueTags.insert(tag.trimmed());
            }
        }
    }

    allTags = uniqueTags.values();
    allTags.sort();

    return allTags;
}

void InspirationModel::refresh()
{
    loadInspirations();
}

QDateTime InspirationModel::getCurrentTimestamp() const
{
    return QDateTime::currentDateTime();
}

bool InspirationModel::restoreInspiration(int id)
{
    QSqlQuery query(db);
    query.prepare("UPDATE inspirations SET is_deleted = 0 WHERE id = ?");
    query.addBindValue(id);
    if (query.exec()) {
        refresh();
        return true;
    }
    return false;
}

bool InspirationModel::permanentDeleteInspiration(int id)
{
    QSqlQuery query(db);
    query.prepare("DELETE FROM inspirations WHERE id = ?");
    query.addBindValue(id);
    return query.exec();
}

QList<QVariantMap> InspirationModel::getDeletedInspirations() const
{
    QList<QVariantMap> result;
    QSqlQuery query(db);
    query.prepare("SELECT * FROM inspirations WHERE is_deleted = 1 ORDER BY updated_at DESC");
    if (query.exec()) {
        while (query.next()) {
            QVariantMap item;
            item["id"] = query.value("id");
            item["content"] = query.value("content");
            item["tags"] = query.value("tags");
            item["created_at"] = query.value("created_at");
            item["updated_at"] = query.value("updated_at");
            result.append(item);
        }
    }
    return result;
}

bool InspirationModel::emptyRecycleBin()
{
    QSqlQuery query(db);
    return query.exec("DELETE FROM inspirations WHERE is_deleted = 1");
}

static QString updateTagString(const QString &tags, const QString &oldTag, const QString &newTag = QString())
{
    QStringList tagList = tags.split(",", Qt::SkipEmptyParts);
    QStringList newTagList;
    bool changed = false;

    for (const QString &t : tagList) {
        QString trimmed = t.trimmed();
        if (trimmed == oldTag) {
            if (!newTag.isEmpty()) {
                newTagList.append(newTag);
            }
            changed = true;
        } else {
            newTagList.append(trimmed);
        }
    }

    if (!changed) return tags;
    return newTagList.join(",");
}

bool InspirationModel::renameTag(const QString &oldName, const QString &newName)
{
    if (oldName == newName) return false;

    QSqlQuery query(db);
    query.prepare("SELECT id, tags FROM inspirations WHERE tags LIKE ?");
    query.addBindValue("%" + oldName + "%");

    if (!query.exec()) return false;

    db.transaction();
    while (query.next()) {
        int id = query.value("id").toInt();
        QString tags = query.value("tags").toString();
        QString newTags = updateTagString(tags, oldName, newName);

        if (tags != newTags) {
            QSqlQuery updateQuery(db);
            updateQuery.prepare("UPDATE inspirations SET tags = ? WHERE id = ?");
            updateQuery.addBindValue(newTags);
            updateQuery.addBindValue(id);
            updateQuery.exec();
        }
    }
    db.commit();
    refresh();
    return true;
}

bool InspirationModel::removeTagFromAll(const QString &tagName)
{
    return renameTag(tagName, "");
}
</file>

<file path="models/taskfiltermodel.cpp">
#include "taskfiltermodel.h"
#include "models/taskmodel.h"
#include <QDateTime>
#include <QDebug>
#include <QMimeData>

TaskFilterModel::TaskFilterModel(QObject *parent)
    : QSortFilterProxyModel(parent)
    , m_mode(FilterAll)
    , m_targetStatus(0)
    , m_categoryId(-1)
    , m_priority(-1)
    , m_useDateFilter(false)
{
    setDynamicSortFilter(true);
}

void TaskFilterModel::setFilterMode(FilterMode mode)
{
    m_mode = mode;
    invalidateFilter();
}

void TaskFilterModel::setFilterStatus(int status)
{
    m_targetStatus = status;
    if (m_mode == FilterStatus) {
        invalidateFilter();
    }
}

void TaskFilterModel::setFilterCategory(int categoryId)
{
    m_categoryId = categoryId;
    invalidateFilter();
}

void TaskFilterModel::setFilterPriority(int priority)
{
    m_priority = priority;
    invalidateFilter();
}

void TaskFilterModel::setFilterText(const QString &text)
{
    m_searchText = text.trimmed().toLower();
    invalidateFilter();
}

void TaskFilterModel::setFilterDateRange(const QDate &start, const QDate &end)
{
    m_useDateFilter = true;
    m_startDate = start;
    m_endDate = end;
    invalidateFilter();
}

void TaskFilterModel::clearDateFilter()
{
    m_useDateFilter = false;
    invalidateFilter();
}

bool TaskFilterModel::filterAcceptsRow(int source_row, const QModelIndex &source_parent) const
{
    QModelIndex index = sourceModel()->index(source_row, 0, source_parent);

    bool isDeleted = sourceModel()->data(index, TaskModel::IsDeletedRole).toBool();
    if (isDeleted) return false;

    int status = sourceModel()->data(index, TaskModel::StatusRole).toInt();

    if (m_mode == FilterUncompleted) {
        if (status == 2) return false;
    } else if (m_mode == FilterCompleted) {
        if (status != 2) return false;
    } else if (m_mode == FilterStatus) {
        if (status != m_targetStatus) return false;
    }

    if (m_categoryId != -1) {
        int catId = sourceModel()->data(index, TaskModel::CategoryIdRole).toInt();
        if (catId != m_categoryId) return false;
    }

    if (m_priority != -1) {
        int pri = sourceModel()->data(index, TaskModel::PriorityRole).toInt();
        if (pri != m_priority) return false;
    }

    if (!m_searchText.isEmpty()) {
        QString title = sourceModel()->data(index, TaskModel::TitleRole).toString().toLower();
        QString desc = sourceModel()->data(index, TaskModel::DescriptionRole).toString().toLower();
        if (!title.contains(m_searchText) && !desc.contains(m_searchText)) {
            return false;
        }
    }
    if (m_useDateFilter) {
        QDateTime deadline = sourceModel()->data(index, TaskModel::DeadlineRole).toDateTime();
        if (!deadline.isValid()) return false;
        QDate date = deadline.date();
        if (date < m_startDate || date > m_endDate) return false;
    }

    return true;
}

bool TaskFilterModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
{
    if (source_left.column() == 3) {
        int leftPriority = sourceModel()->data(source_left, TaskModel::PriorityRole).toInt();
        int rightPriority = sourceModel()->data(source_right, TaskModel::PriorityRole).toInt();
        return leftPriority < rightPriority;
    }

    if (source_left.column() == 4) {
        int leftStatus = sourceModel()->data(source_left, TaskModel::StatusRole).toInt();
        int rightStatus = sourceModel()->data(source_right, TaskModel::StatusRole).toInt();
        return leftStatus < rightStatus;
    }

    if (source_left.column() == 5 || source_left.column() == 6 || source_left.column() == 7) {
        QString leftStr = sourceModel()->data(source_left, Qt::DisplayRole).toString();
        QString rightStr = sourceModel()->data(source_right, Qt::DisplayRole).toString();
        if (leftStr == "-") return false;
        if (rightStr == "-") return true;
        return leftStr < rightStr;
    }

    return QSortFilterProxyModel::lessThan(source_left, source_right);
}

QVariant TaskFilterModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
        if (m_mode == FilterCompleted && section == 7) {
            return "完成时间";
        }
    }
    return QSortFilterProxyModel::headerData(section, orientation, role);
}

Qt::ItemFlags TaskFilterModel::flags(const QModelIndex &index) const
{
    if (!index.isValid())
        return Qt::NoItemFlags | Qt::ItemIsDropEnabled;

    return QSortFilterProxyModel::flags(index);
}

Qt::DropActions TaskFilterModel::supportedDropActions() const
{
    if (sourceModel())
        return sourceModel()->supportedDropActions();
    return Qt::CopyAction | Qt::MoveAction;
}

Qt::DropActions TaskFilterModel::supportedDragActions() const
{
    if (sourceModel())
        return sourceModel()->supportedDragActions();
    return Qt::CopyAction | Qt::MoveAction;
}

QStringList TaskFilterModel::mimeTypes() const
{
    if (sourceModel())
        return sourceModel()->mimeTypes();
    return QStringList();
}

QMimeData *TaskFilterModel::mimeData(const QModelIndexList &indexes) const
{
    if (sourceModel()) {
        QModelIndexList sourceIndexes;
        for (const QModelIndex &index : indexes) {
            sourceIndexes << mapToSource(index);
        }
        return sourceModel()->mimeData(sourceIndexes);
    }
    return nullptr;
}
</file>

<file path="models/taskfiltermodel.h">
#ifndef TASKFILTERMODEL_H
#define TASKFILTERMODEL_H

#include <QSortFilterProxyModel>
#include <QDate>

class TaskFilterModel : public QSortFilterProxyModel
{
    Q_OBJECT

public:
    enum FilterMode {
        FilterAll,
        FilterUncompleted,
        FilterCompleted,
        FilterStatus
    };

    explicit TaskFilterModel(QObject *parent = nullptr);
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
    Qt::ItemFlags flags(const QModelIndex &index) const override;
    Qt::DropActions supportedDropActions() const override;
    Qt::DropActions supportedDragActions() const override;
    QStringList mimeTypes() const override;
    QMimeData *mimeData(const QModelIndexList &indexes) const override;

    void setFilterMode(FilterMode mode);
    void setFilterStatus(int status);
    void setFilterCategory(int categoryId);
    void setFilterPriority(int priority);
    void setFilterText(const QString &text);
    void setFilterDateRange(const QDate &start, const QDate &end);
    void clearDateFilter();

protected:
    bool filterAcceptsRow(int source_row, const QModelIndex &source_parent) const override;
    bool lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const override;

private:
    FilterMode m_mode;
    int m_targetStatus;
    int m_categoryId;
    int m_priority;
    QString m_searchText;
    bool m_useDateFilter;
    QDate m_startDate;
    QDate m_endDate;
};

#endif // TASKFILTERMODEL_H
</file>

<file path="resources/styles/dialog.qss">
/* 任务编辑框 - 详细描述 */
#textEditDescription {
    min-height: 57px; /* 防止被压扁 */
    background-color: #2d2d2d;
    color: #ffffff;
    border: 1px solid #3d3d3d;
    border-radius: 4px;
}

/* 任务编辑框 - 分类下拉框 */
QComboBox#comboBoxCategory {
    background-color: #2d2d2d;
    color: #ffffff;
    border: 1px solid #3d3d3d;
    border-radius: 4px;
    padding: 0px 8px;
    min-height: 30px;
}

QComboBox#comboBoxCategory:hover {
    border: 1px solid #657896;
    background-color: #3d3d3d;
}

QComboBox#comboBoxCategory::drop-down {
    border: none;
    width: 20px;
}

QComboBox#comboBoxCategory QAbstractItemView {
    background-color: #2d2d2d;
    color: #ffffff;
    selection-background-color: #657896;
    selection-color: #ffffff;
    border: 1px solid #3d3d3d;
    outline: none;
}

/* 标签管理 - 现有标签按钮 */
QPushButton#existingTagBtn {
    background-color: transparent;
    color: #CCCCCC;
    border-radius: 4px;
    padding: 0px 8px;
    font-size: 11px;
    min-height: 20px;
    max-height: 24px;
    margin: 2px;
    border: 1px solid transparent;
}

QPushButton#existingTagBtn:hover {
    color: white;
}

/* 内容编辑框 */
QTextEdit#inspirationContentEdit {
    background-color: #2d2d2d;
    color: #ffffff;
    border: 1px solid #3d3d3d;
    border-radius: 4px;
    padding: 8px;
    font-size: 14px;
    selection-background-color: #657896;
}

QTextEdit#inspirationContentEdit:focus {
    border: 1px solid #657896;
}

/* 标签输入框 */
QLineEdit#inspirationTagEdit {
    background-color: #2d2d2d;
    border: 1px solid #3d3d3d;
    border-radius: 15px;
    padding: 4px 12px;
    color: #cccccc;
}

QLineEdit#inspirationTagEdit:focus {
    border: 1px solid #657896;
}

QPushButton#saveInspirationBtn {
    background-color: #657896;
    color: white;
    font-weight: bold;
    border: none;
}

QPushButton#saveInspirationBtn:hover {
    background-color: #7a8ca8;
}

/* --- 标签检索对话框 --- */

/* "All" 按钮 */
QPushButton#tagSearchAllBtn {
    background-color: #657896;
    color: white;
    border-radius: 13px;
    border: 1px solid #657896;
    padding: 0px 13px;
    font-size: 14px;
}

QPushButton#tagSearchAllBtn:checked {
    background-color: #657896;
    border-color: #888;
    font-weight: bold;
}

QPushButton#tagSearchAllBtn:hover {
    background-color: #5d5d5d;
}

/* 普通标签按钮 */
QPushButton[class="tagSearchBtn"] {
    background-color: transparent;
    border-radius: 13px;
    border-width: 3px;
    padding: 0px 13px;
    font-size: 14px;
    font-weight: bold;
}
</file>

<file path="views/calenderview.cpp">
#include "calenderview.h"
#include <QTableView>
#include <QMouseEvent>
#include <QEvent>
#include "models/taskmodel.h"
#include "models/inspirationmodel.h"
#include <QPainter>
#include <QTextCharFormat>
#include <QDebug>

CalendarView::CalendarView(QWidget *parent)
    : QCalendarWidget(parent)
    , m_model(nullptr)
    , m_inspirationModel(nullptr)
    , m_filterCategoryId(-1)
    , m_filterPriority(-1)
{
    setGridVisible(true);
    setVerticalHeaderFormat(QCalendarWidget::NoVerticalHeader);

    QTextCharFormat weekendFormat;
    weekendFormat.setForeground(QColor("#99B6E3"));
    setWeekdayTextFormat(Qt::Saturday, weekendFormat);
    setWeekdayTextFormat(Qt::Sunday, weekendFormat);

    if (QTableView *view = getInternalView()) {
        view->viewport()->installEventFilter(this);
        view->setMouseTracking(true);
    }
}

void CalendarView::setTaskModel(TaskModel *model)
{
    m_model = model;
    if (m_model) {
        connect(m_model, &TaskModel::modelReset, this, &CalendarView::refreshTasks);
        connect(m_model, &TaskModel::layoutChanged, this, &CalendarView::refreshTasks);
        connect(m_model, &TaskModel::rowsInserted, this, &CalendarView::refreshTasks);
        connect(m_model, &TaskModel::rowsRemoved, this, &CalendarView::refreshTasks);
        connect(m_model, &TaskModel::dataChanged, this, &CalendarView::refreshTasks);
        refreshTasks();
    }
}

void CalendarView::setInspirationModel(InspirationModel *model)
{
    m_inspirationModel = model;
    if (m_inspirationModel) {
        connect(m_inspirationModel, &InspirationModel::modelReset, this, &CalendarView::refreshTasks);
        connect(m_inspirationModel, &InspirationModel::rowsInserted, this, &CalendarView::refreshTasks);
        connect(m_inspirationModel, &InspirationModel::rowsRemoved, this, &CalendarView::refreshTasks);
        connect(m_inspirationModel, &InspirationModel::dataChanged, this, &CalendarView::refreshTasks);
        refreshTasks();
    }
}

void CalendarView::refreshTasks()
{
    updateTaskCache();
    update();
}

void CalendarView::updateTaskCache()
{
    m_taskStatusColors.clear();
    m_inspirationDates.clear();

    if (m_model && m_filterCategoryId != -2) {
        QList<QVariantMap> tasks = m_model->getAllTasks(false);

        struct DayStats {
            bool hasDelayed = false;
            bool hasInProgress = false;
            bool hasTodo = false;
            int totalCount = 0;
            int completedCount = 0;
        };
        QMap<QDate, DayStats> statsMap;

        for (const QVariantMap &task : tasks) {
            if (m_filterCategoryId != -1) {
                if (task["category_id"].toInt() != m_filterCategoryId) continue;
            }
            if (m_filterPriority != -1) {
                if (task["priority"].toInt() != m_filterPriority) continue;
            }

            QDateTime deadline = task["deadline"].toDateTime();
            if (!deadline.isValid()) continue;

            QDate date = deadline.date();
            DayStats &stats = statsMap[date];
            stats.totalCount++;

            int status = task["status"].toInt();
            if (status == 3) stats.hasDelayed = true;
            else if (status == 1) stats.hasInProgress = true;
            else if (status == 0) stats.hasTodo = true;
            else if (status == 2) stats.completedCount++;
        }

        for (auto it = statsMap.begin(); it != statsMap.end(); ++it) {
            const DayStats &s = it.value();
            QColor color;

            if (s.hasDelayed) color = QColor("#F44336");
            else if (s.hasInProgress) color = QColor("#FF9800");
            else if (s.hasTodo) color = QColor("#2196F3");
            else if (s.totalCount > 0 && s.totalCount == s.completedCount) color = QColor("#4CAF50");

            if (color.isValid()) {
                m_taskStatusColors[it.key()] = color;
            }
        }
    }

    if (m_inspirationModel && (m_filterCategoryId == -1 || m_filterCategoryId == -2)) {
        m_inspirationDates = m_inspirationModel->getDatesWithInspirations(m_inspFilterTags, m_inspFilterMatchAll);
    }
}

void CalendarView::paintCell(QPainter *painter, const QRect &rect, QDate date) const
{
    QCalendarWidget::paintCell(painter, rect, date);

    painter->save();
    painter->setRenderHint(QPainter::Antialiasing);

    int dotSize = 12;
    int margin = 4;

    m_inspRects.remove(date);
    m_taskRects.remove(date);

    if (m_inspirationDates.contains(date)) {
        QRect inspRect(rect.left() + margin, rect.bottom() - margin - dotSize, dotSize, dotSize);
        m_inspRects[date] = inspRect;

        painter->setBrush(QColor("#9b59b6"));
        painter->setPen(Qt::NoPen);
        painter->drawEllipse(inspRect);
    }

    if (m_taskStatusColors.contains(date)) {
        QRect taskRect(rect.right() - margin - dotSize, rect.bottom() - margin - dotSize, dotSize, dotSize);
        m_taskRects[date] = taskRect;

        QColor dotColor = m_taskStatusColors[date];
        painter->setBrush(dotColor);
        painter->setPen(Qt::NoPen);
        painter->drawEllipse(taskRect);
    }

    painter->restore();
}

QTableView* CalendarView::getInternalView() const
{
    return findChild<QTableView*>("qt_calendar_calendarview");
}

bool CalendarView::eventFilter(QObject *watched, QEvent *event)
{
    QTableView *view = getInternalView();
    if (watched == view->viewport() && event->type() == QEvent::MouseButtonPress) {
        QMouseEvent *me = static_cast<QMouseEvent*>(event);
        QPoint pos = me->pos();

        int tolerance = 2;

        for (auto it = m_inspRects.begin(); it != m_inspRects.end(); ++it) {
            if (it.value().adjusted(-tolerance, -tolerance, tolerance, tolerance).contains(pos)) {
                emit showInspirations(it.key());
                return true;
            }
        }

        for (auto it = m_taskRects.begin(); it != m_taskRects.end(); ++it) {
            if (it.value().adjusted(-tolerance, -tolerance, tolerance, tolerance).contains(pos)) {
                emit showTasks(it.key());
                return true;
            }
        }
    }
    return QCalendarWidget::eventFilter(watched, event);
}

void CalendarView::setFilter(int categoryId, int priority)
{
    m_filterCategoryId = categoryId;
    m_filterPriority = priority;
    refreshTasks();
}

void CalendarView::setInspirationFilter(const QStringList &tags, bool matchAll)
{
    m_inspFilterTags = tags;
    m_inspFilterMatchAll = matchAll;
    refreshTasks();
}
</file>

<file path="views/calenderview.h">
#ifndef CALENDARVIEW_H
#define CALENDARVIEW_H

#include <QCalendarWidget>
#include <QMap>
#include <QDate>

class TaskModel;
class QTableView;

class CalendarView : public QCalendarWidget
{
    Q_OBJECT
public:
    explicit CalendarView(QWidget *parent = nullptr);
    void setTaskModel(TaskModel *model);
    void setInspirationModel(class InspirationModel *model);
    void refreshTasks();
    void setFilter(int categoryId, int priority);
    void setInspirationFilter(const QStringList &tags, bool matchAll);

signals:
    void showInspirations(const QDate &date);
    void showTasks(const QDate &date);

protected:
    void paintCell(QPainter *painter, const QRect &rect, QDate date) const override;
    bool eventFilter(QObject *watched, QEvent *event) override;

private:
    TaskModel *m_model;
    class InspirationModel *m_inspirationModel;

    QMap<QDate, QColor> m_taskStatusColors;
    QList<QDate> m_inspirationDates;

    mutable QMap<QDate, QRect> m_inspRects;
    mutable QMap<QDate, QRect> m_taskRects;

    void updateTaskCache();
    QTableView* getInternalView() const;

    int m_filterCategoryId = -1;
    int m_filterPriority = -1;
    QStringList m_inspFilterTags;
    bool m_inspFilterMatchAll = false;
};

#endif // CALENDARVIEW_H
</file>

<file path="views/inspirationview.cpp">
#include "inspirationview.h"
#include "models/inspirationmodel.h"
#include "dialogs/inspirationdialog.h"
#include "views/calenderview.h"
#include "models/taskmodel.h"
#include "dialogs/inspirationrecyclebindialog.h"
#include "dialogs/inspirationtagsearchdialog.h"
#include <QPainter>
#include <QDateTime>
#include <QListWidget>
#include <QStackedWidget>
#include <QButtonGroup>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QTableView>
#include <QLineEdit>
#include <QPushButton>
#include <QHeaderView>
#include <QComboBox>
#include <QLabel>
#include <QMessageBox>
#include <QDebug>

InspirationGridDelegate::InspirationGridDelegate(QObject *parent)
    : QStyledItemDelegate(parent)
{
}

void InspirationGridDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    if (!index.isValid()) return;

    painter->save();
    painter->setRenderHint(QPainter::Antialiasing);

    QVariantMap data = index.data(Qt::UserRole).toMap();
    QString content = data["content"].toString();
    QDateTime createTime = data["created_at"].toDateTime();
    QString timeStr = createTime.isValid() ? createTime.toString("MM-dd HH:mm") : "";

    QRect rect = option.rect.adjusted(6, 6, -6, -6);

    QColor bgColor;
    QColor borderColor;

    if (option.state & QStyle::State_Selected) {
        bgColor = QColor(100, 125, 160, 160);
        borderColor = QColor(160, 170, 230, 220);
    } else if (option.state & QStyle::State_MouseOver) {
        bgColor = QColor(150, 185, 220, 110);
        borderColor = QColor(255, 255, 255, 160);
    } else {
        bgColor = QColor(135, 160, 190, 90);
        borderColor = QColor(255, 255, 255, 50);
    }

    painter->setBrush(bgColor);
    painter->setPen(QPen(borderColor, 1));
    painter->drawRoundedRect(rect, 10, 10);

    painter->setPen(QColor(245, 245, 255));
    QRect textRect = rect.adjusted(12, 12, -12, -25);
    painter->drawText(textRect, Qt::AlignLeft | Qt::AlignTop | Qt::TextWordWrap, content);

    painter->setPen(QColor(255, 255, 255, 140));
    QFont timeFont = painter->font();
    timeFont.setPointSizeF(9);
    painter->setFont(timeFont);
    painter->drawText(rect.adjusted(0, 0, -10, -8), Qt::AlignRight | Qt::AlignBottom, timeStr);

    painter->restore();
}

QSize InspirationGridDelegate::sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    Q_UNUSED(option);
    Q_UNUSED(index);
    return QSize(165, 120);
}

InspirationView::InspirationView(QWidget *parent)
    : QWidget(parent), m_model(nullptr)
{
    setupUI();
}

void InspirationView::setupUI()
{
    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->setContentsMargins(10, 10, 10, 10);

    QHBoxLayout *toolLayout = new QHBoxLayout();

    QPushButton *addBtn = new QPushButton("记录", this);
    addBtn->setObjectName("addInspirationBtn");
    addBtn->setIcon(QIcon(":/icons/add_icon.png"));

    QPushButton *editBtn = new QPushButton("编辑", this);
    editBtn->setObjectName("editInspirationBtn");
    editBtn->setIcon(QIcon(":/icons/edit_icon.png"));

    QPushButton *deleteBtn = new QPushButton("删除", this);
    deleteBtn->setObjectName("deleteInspirationBtn");
    deleteBtn->setIcon(QIcon(":/icons/delete_icon.png"));

    toolLayout->addWidget(addBtn);
    toolLayout->addWidget(editBtn);
    toolLayout->addWidget(deleteBtn);

    toolLayout->addSpacing(10);

    m_searchEdit = new QLineEdit(this);
    m_searchEdit->setPlaceholderText("搜索灵感内容...");
    m_searchEdit->setFixedWidth(460);
    toolLayout->addWidget(m_searchEdit);
    toolLayout->addStretch();

    QPushButton *tagSearchBtn = new QPushButton("标签检索", this);
    tagSearchBtn->setObjectName("inspirationTagSearchBtn");
    tagSearchBtn->setIcon(QIcon(":/icons/edit_icon.png"));

    toolLayout->addWidget(tagSearchBtn);

    QPushButton *recycleBinBtn = new QPushButton("回收站", this);
    recycleBinBtn->setObjectName("inspirationRecycleBinBtn");
    recycleBinBtn->setIcon(QIcon(":/icons/recycle_icon.png"));

    QPushButton *refreshBtn = new QPushButton("刷新", this);
    refreshBtn->setObjectName("inspirationRefreshBtn");
    refreshBtn->setIcon(QIcon(":/icons/refresh_icon.png"));

    toolLayout->addWidget(recycleBinBtn);
    toolLayout->addWidget(refreshBtn);

    layout->addLayout(toolLayout);

    m_viewStack = new QStackedWidget(this);

    m_tableView = new QTableView(this);
    m_tableView->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_tableView->setSelectionMode(QAbstractItemView::SingleSelection);
    m_tableView->setAlternatingRowColors(true);
    m_tableView->verticalHeader()->setVisible(false);
    m_tableView->setShowGrid(false);
    m_tableView->setFrameShape(QFrame::NoFrame);
    m_viewStack->addWidget(m_tableView);

    m_gridView = new QListWidget(this);
    m_gridView->setViewMode(QListWidget::IconMode);
    m_gridView->setResizeMode(QListWidget::Adjust);
    m_gridView->setSpacing(8);
    m_gridView->setMovement(QListWidget::Static);
    m_gridView->setSelectionMode(QListWidget::SingleSelection);
    m_gridView->setStyleSheet("QListWidget { background-color: transparent; border: none; }");
    m_gridView->setItemDelegate(new InspirationGridDelegate(this));

    QFont font = m_gridView->font();
    font.setPointSize(10);
    m_gridView->setFont(font);

    m_viewStack->addWidget(m_gridView);

    m_calendarView = new CalendarView(this);
    m_viewStack->addWidget(m_calendarView);

    connect(m_calendarView, &CalendarView::showInspirations,
            this, &InspirationView::showInspirationsRequested);
    connect(m_calendarView, &CalendarView::showTasks,
            this, &InspirationView::showTasksRequested);

    layout->addWidget(m_viewStack);

    QHBoxLayout *bottomLayout = new QHBoxLayout();

    m_leftBottomContainer = new QWidget(this);
    m_leftBottomContainer->setFixedWidth(195);
    QHBoxLayout *leftLayout = new QHBoxLayout(m_leftBottomContainer);
    leftLayout->setContentsMargins(0, 0, 0, 0);
    leftLayout->setSpacing(5);

    m_dateFilterCheck = new QCheckBox("筛选:", this);
    m_dateFilterCheck->setChecked(true);
    m_dateFilterCheck->setStyleSheet("color: #cccccc;");

    m_yearSpin = new QSpinBox(this);
    m_yearSpin->setRange(2000, 2099);
    m_yearSpin->setValue(QDate::currentDate().year());
    m_yearSpin->setSuffix("年");
    m_yearSpin->setFixedWidth(70);
    m_yearSpin->setStyleSheet(
        "QSpinBox { background-color: #2d2d2d; color: #ffffff; border: 1px solid #3d3d3d; border-radius: 4px; padding: 2px; }"
        "QSpinBox::up-button, QSpinBox::down-button { width: 16px; }"
        );

    m_monthSpin = new QSpinBox(this);
    m_monthSpin->setRange(1, 12);
    m_monthSpin->setValue(QDate::currentDate().month());
    m_monthSpin->setSuffix("月");
    m_monthSpin->setFixedWidth(55);
    m_monthSpin->setStyleSheet(m_yearSpin->styleSheet());

    connect(m_dateFilterCheck, &QCheckBox::toggled, this, [this](bool checked){
        m_yearSpin->setEnabled(checked);
        m_monthSpin->setEnabled(checked);
        applyFilters();
    });

    connect(m_yearSpin, QOverload<int>::of(&QSpinBox::valueChanged),
            this, [this](int){ applyFilters(); });
    connect(m_monthSpin, QOverload<int>::of(&QSpinBox::valueChanged),
            this, [this](int){ applyFilters(); });

    leftLayout->addWidget(m_dateFilterCheck);
    leftLayout->addWidget(m_yearSpin);
    leftLayout->addWidget(m_monthSpin);

    QButtonGroup *viewGroup = new QButtonGroup(this);

    QPushButton *listViewBtn = new QPushButton("列表视图", this);
    listViewBtn->setCheckable(true);
    listViewBtn->setChecked(true);
    listViewBtn->setObjectName("listViewBtn");

    QPushButton *gridViewBtn = new QPushButton("便利贴墙", this);
    gridViewBtn->setCheckable(true);
    gridViewBtn->setObjectName("kanbanViewBtn");

    QPushButton *calendarViewBtn = new QPushButton("日历视图", this);
    calendarViewBtn->setCheckable(true);
    calendarViewBtn->setObjectName("calendarViewBtn");

    viewGroup->addButton(listViewBtn, 0);
    viewGroup->addButton(gridViewBtn, 1);
    viewGroup->addButton(calendarViewBtn, 2);

    QHBoxLayout *centerBtnLayout = new QHBoxLayout();
    centerBtnLayout->addWidget(listViewBtn);
    centerBtnLayout->addWidget(gridViewBtn);
    centerBtnLayout->addWidget(calendarViewBtn);

    QWidget *rightDummy = new QWidget(this);
    rightDummy->setFixedWidth(195);

    bottomLayout->addWidget(m_leftBottomContainer);
    bottomLayout->addStretch();
    bottomLayout->addLayout(centerBtnLayout);
    bottomLayout->addStretch();
    bottomLayout->addWidget(rightDummy);

    layout->addLayout(bottomLayout);

    connect(viewGroup, &QButtonGroup::idClicked, this, [this, rightDummy](int id){
        m_viewStack->setCurrentIndex(id);

        bool showDateFilter = (id != 2);
        m_leftBottomContainer->setVisible(showDateFilter);
        rightDummy->setVisible(showDateFilter);
    });

    connect(m_searchEdit, &QLineEdit::textChanged,
            this, &InspirationView::onSearchTextChanged);

    connect(m_tableView, &QTableView::doubleClicked,
            this, &InspirationView::onDoubleClicked);

    connect(m_gridView, &QListWidget::itemDoubleClicked, this, [this](QListWidgetItem *item){
        int id = item->data(Qt::UserRole).toMap()["id"].toInt();
        for(int i = 0; i < m_model->rowCount(); ++i) {
            QModelIndex idx = m_model->index(i, 0);
            if (m_model->data(idx, Qt::UserRole).toMap()["id"].toInt() == id) {
                onDoubleClicked(idx);
                break;
            }
        }
    });

    connect(addBtn, &QPushButton::clicked, this, &InspirationView::onAddClicked);
    connect(editBtn, &QPushButton::clicked, this, &InspirationView::onEditClicked);
    connect(deleteBtn, &QPushButton::clicked, this, &InspirationView::onDeleteClicked);
    connect(refreshBtn, &QPushButton::clicked, this, &InspirationView::refresh);
    connect(tagSearchBtn, &QPushButton::clicked, this, &InspirationView::onTagSearchClicked);

    connect(recycleBinBtn, &QPushButton::clicked, this, [this](){
        if (!m_model) return;
        InspirationRecycleBinDialog dlg(m_model, this);
        dlg.exec();
        refresh();
    });
}

void InspirationView::setModel(InspirationModel *model)
{
    m_model = model;
    m_tableView->setModel(model);

    m_tableView->horizontalHeader()->setMinimumSectionSize(100);
    m_tableView->horizontalHeader()->setStretchLastSection(true);
    m_tableView->setColumnWidth(0, 160);
    m_tableView->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Interactive);
    m_tableView->setColumnWidth(1, 650);
    m_tableView->horizontalHeader()->setSectionResizeMode(1, QHeaderView::Interactive);
    m_tableView->horizontalHeader()->setSectionResizeMode(2, QHeaderView::Interactive);

    m_calendarView->setInspirationModel(model);

    refreshGridView();

    connect(model, &QAbstractTableModel::modelReset, this, &InspirationView::refreshGridView);
    connect(model, &QAbstractTableModel::rowsInserted, this, &InspirationView::refreshGridView);
    connect(model, &QAbstractTableModel::rowsRemoved, this, &InspirationView::refreshGridView);
    connect(model, &QAbstractTableModel::dataChanged, this, &InspirationView::refreshGridView);
}

void InspirationView::refresh()
{
    if (m_model) {
        m_model->refresh();

        m_filterTags.clear();
        m_filterMatchAll = false;
        m_searchEdit->clear();

        QDate current = QDate::currentDate();
        m_yearSpin->blockSignals(true);
        m_monthSpin->blockSignals(true);
        m_yearSpin->setValue(current.year());
        m_monthSpin->setValue(current.month());
        m_dateFilterCheck->setChecked(true);
        m_yearSpin->blockSignals(false);
        m_monthSpin->blockSignals(false);

        applyFilters();
    }
}

void InspirationView::onTagSearchClicked()
{
    if (!m_model) return;

    InspirationTagSearchDialog dlg(m_model, m_filterTags, this);
    if (dlg.exec() == QDialog::Accepted) {
        m_filterTags = dlg.getSelectedTags();
        m_filterMatchAll = dlg.isMatchAll();
        applyFilters();
    }
}

void InspirationView::applyFilters()
{
    if (!m_model) return;

    if (m_calendarView) {
        m_calendarView->setInspirationFilter(m_filterTags, m_filterMatchAll);
    }

    QString search = m_searchEdit->text();

    bool filterDate = m_dateFilterCheck->isChecked();
    int targetYear = m_yearSpin->value();
    int targetMonth = m_monthSpin->value();

    for (int i = 0; i < m_model->rowCount(); ++i) {
        QModelIndex idx = m_model->index(i, 0);
        QVariantMap data = m_model->data(idx, Qt::UserRole).toMap();

        QString content = data["content"].toString();
        QString tagsStr = data["tags"].toString();
        QDateTime createTime = data["created_at"].toDateTime();
        QStringList itemTags = tagsStr.split(",", Qt::SkipEmptyParts);

        bool dateMatch = true;
        if (filterDate) {
            if (createTime.date().year() != targetYear ||
                createTime.date().month() != targetMonth) {
                dateMatch = false;
            }
        }

        bool tagMatch = true;
        if (!m_filterTags.isEmpty()) {
            if (m_filterMatchAll) {
                for (const QString &filterTag : m_filterTags) {
                    bool found = false;
                    for (const QString &itemTag : itemTags) {
                        if (itemTag.trimmed() == filterTag) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        tagMatch = false;
                        break;
                    }
                }
            } else {
                tagMatch = false;
                for (const QString &filterTag : m_filterTags) {
                    for (const QString &itemTag : itemTags) {
                        if (itemTag.trimmed() == filterTag) {
                            tagMatch = true;
                            break;
                        }
                    }
                    if (tagMatch) break;
                }
            }
        }

        bool searchMatch = search.isEmpty() ||
                           content.contains(search, Qt::CaseInsensitive) ||
                           tagsStr.contains(search, Qt::CaseInsensitive);

        bool shouldShow = dateMatch && tagMatch && searchMatch;

        m_tableView->setRowHidden(i, !shouldShow);

        if (m_gridView && i < m_gridView->count()) {
            m_gridView->item(i)->setHidden(!shouldShow);
        }
    }
}

void InspirationView::onSearchTextChanged(const QString &text)
{
    Q_UNUSED(text);
    applyFilters();
}

void InspirationView::onDoubleClicked(const QModelIndex &index)
{
    if (!m_model) return;

    QVariantMap data = m_model->data(index, Qt::UserRole).toMap();
    InspirationDialog dialog(data, this);

    if (dialog.exec() == QDialog::Accepted) {
        QVariantMap newData = dialog.getData();

        if (newData.contains("id")) {
            m_model->updateInspiration(newData["id"].toInt(), newData["content"].toString(), newData["tags"].toString());
        } else {
            m_model->addInspiration(newData["content"].toString(), newData["tags"].toString());
        }

        applyFilters();
    }
}
void InspirationView::onAddClicked()
{
    InspirationDialog dialog(this);
    if (dialog.exec() == QDialog::Accepted) {
        QVariantMap data = dialog.getData();
        m_model->addInspiration(data["content"].toString(), data["tags"].toString());
        m_tableView->scrollToTop();
    }
}

void InspirationView::onDeleteClicked()
{
    QModelIndex index = m_tableView->currentIndex();
    if (!index.isValid()) {
        QMessageBox::warning(this, "提示", "请先选择一条记录");
        return;
    }

    if (QMessageBox::question(this, "确认", "确定要删除这条灵感吗？") == QMessageBox::Yes) {
        int id = m_model->data(index, Qt::UserRole).toMap()["id"].toInt();
        m_model->deleteInspiration(id);
    }
}

void InspirationView::onEditClicked()
{
    QModelIndex index = m_tableView->currentIndex();
    if (index.isValid()) {
        onDoubleClicked(index);
    } else {
        QMessageBox::warning(this, "提示", "请先选择一条灵感记录");
    }
}

void InspirationView::refreshGridView()
{
    if (!m_gridView || !m_model) return;

    m_gridView->clear();
    QList<QVariantMap> inspirations = m_model->getAllInspirations();

    for (const QVariantMap &data : inspirations) {
        QListWidgetItem *item = new QListWidgetItem();
        item->setData(Qt::UserRole, data);
        m_gridView->addItem(item);
    }
}

void InspirationView::setTaskModel(TaskModel *model)
{
    if (m_calendarView) {
        m_calendarView->setTaskModel(model);
    }
}
</file>

<file path="views/kanbanview.cpp">
#include "kanbanview.h"
#include "models/taskmodel.h"
#include "models/taskfiltermodel.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QPainter>
#include <QDragEnterEvent>
#include <QMimeData>
#include <QDebug>
#include <QDrag>
#include <QComboBox>

KanbanDelegate::KanbanDelegate(QObject *parent) : QStyledItemDelegate(parent) {}

QSize KanbanDelegate::sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    Q_UNUSED(option);
    Q_UNUSED(index);
    return QSize(200, 72);
}

void KanbanDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const
{
    if (!index.isValid()) return;

    painter->save();
    painter->setRenderHint(QPainter::Antialiasing);

    QString title = index.data(TaskModel::TitleRole).toString();
    QString category = index.data(TaskModel::CategoryNameRole).toString();
    QColor priorityColor = index.data(TaskModel::PriorityColorRole).value<QColor>();

    int status = index.data(TaskModel::StatusRole).toInt();
    QDateTime deadline = index.data(TaskModel::DeadlineRole).toDateTime();
    QDateTime completedAt = index.data(TaskModel::CompletedAtRole).toDateTime();

    QRect rect = option.rect.adjusted(4, 3, -4, -3);

    QColor cardBgColor = QColor("#3d3d3d");
    QColor textColor = QColor("#e0e0e0");
    QColor subTextColor = QColor("#aaaaaa");
    QColor tagBgColor = QColor("#4d4d4d");

    if (option.state & QStyle::State_Selected) {
        painter->setBrush(QColor("#4a5a6d"));
        painter->setPen(QColor("#657896"));
    } else {
        painter->setBrush(cardBgColor);
        painter->setPen(Qt::NoPen);
    }

    painter->drawRoundedRect(rect, 4, 4);

    QRect colorStrip = rect;
    colorStrip.setWidth(4);
    painter->setBrush(priorityColor);
    painter->setPen(Qt::NoPen);
    painter->drawRoundedRect(colorStrip.adjusted(0,0,0,0), 4, 4, Qt::AbsoluteSize);
    painter->drawRect(colorStrip.adjusted(2,0,0,0));

    int leftPadding = 14;
    int rightPadding = 8;

    QFont titleFont = painter->font();
    titleFont.setBold(true);
    titleFont.setPointSize(10);
    painter->setFont(titleFont);
    painter->setPen(textColor);

    QRect titleRect = rect.adjusted(leftPadding, 8, -rightPadding, -28);
    QString elidedTitle = painter->fontMetrics().elidedText(title, Qt::ElideRight, titleRect.width());
    painter->drawText(titleRect, Qt::AlignLeft | Qt::AlignTop, elidedTitle);

    QFont tagFont = painter->font();
    tagFont.setPointSize(8);
    painter->setFont(tagFont);
    QFontMetrics fm(tagFont);

    int catWidth = fm.horizontalAdvance(category) + 12;
    int catHeight = 16;
    QRect catRect(rect.left() + leftPadding, rect.bottom() - 8 - catHeight, catWidth, catHeight);

    painter->setBrush(tagBgColor);
    painter->setPen(Qt::NoPen);
    painter->drawRoundedRect(catRect, 3, 3);
    painter->setPen(subTextColor);
    painter->drawText(catRect, Qt::AlignCenter, category);

    QString timeStr;
    QString prefix;

    if (status == 2) {
        if (completedAt.isValid()) {
            timeStr = completedAt.toString("MM-dd");
            prefix = "√ ";
        }
    } else {
        if (deadline.isValid()) {
            timeStr = deadline.toString("MM-dd");
            if (index.data(TaskModel::IsOverdueRole).toBool()) {
                painter->setPen(QColor("#FF6B6B"));
            }
        }
    }

    if (!timeStr.isEmpty()) {
        QString fullText = prefix + timeStr;
        if (painter->pen().color() != QColor("#FF6B6B")) {
            painter->setPen(subTextColor);
        }
        painter->drawText(rect.adjusted(0, 0, -rightPadding, -8), Qt::AlignRight | Qt::AlignBottom, fullText);
    }

    painter->restore();
}

KanbanColumn::KanbanColumn(int value, QWidget *parent)
    : QListView(parent), m_value(value)
{
    setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

    setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
    setUniformItemSizes(true);

    setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    setResizeMode(QListView::Adjust);

    setAcceptDrops(true);
    setDragEnabled(true);
    setDragDropMode(QAbstractItemView::DragDrop);
    setDefaultDropAction(Qt::MoveAction);
    setSelectionMode(QAbstractItemView::SingleSelection);
    setSpacing(2);
    setStyleSheet("QListView { background-color: transparent; border: none; }");

    setItemDelegate(new KanbanDelegate(this));

    connect(this, &QListView::doubleClicked, this, [this](const QModelIndex &index){
        int taskId = index.data(TaskModel::IdRole).toInt();
        if (taskId > 0) {
            emit taskDoubleClicked(taskId);
        }
    });
}


void KanbanColumn::dropEvent(QDropEvent *event)
{
    if (event->mimeData()->hasFormat("application/x-task-id")) {
        QByteArray encodedData = event->mimeData()->data("application/x-task-id");
        QDataStream stream(&encodedData, QIODevice::ReadOnly);

        int taskId = 0;
        stream >> taskId;

        if (taskId > 0) {
            emit taskDropped(taskId, m_value);
            event->accept();
        }
    } else {
        event->ignore();
    }
}

void KanbanColumn::startDrag(Qt::DropActions supportedActions)
{
    Q_UNUSED(supportedActions);
    QModelIndexList indexes = selectionModel()->selectedIndexes();
    if (indexes.isEmpty()) return;

    QMimeData *mimeData = model()->mimeData(indexes);
    if (!mimeData) return;

    QDrag *drag = new QDrag(this);
    drag->setMimeData(mimeData);

    QPixmap pixmap(viewport()->visibleRegion().boundingRect().size());
    pixmap.fill(Qt::transparent);
    QPainter painter(&pixmap);

    drag->exec(Qt::MoveAction);
}

void KanbanColumn::dragEnterEvent(QDragEnterEvent *event)
{
    if (event->mimeData()->hasFormat("application/x-task-id")) {
        event->setDropAction(Qt::MoveAction);
        event->accept();
    } else {
        event->ignore();
    }
}

void KanbanColumn::dragMoveEvent(QDragMoveEvent *event)
{
    if (event->mimeData()->hasFormat("application/x-task-id")) {
        event->setDropAction(Qt::MoveAction);
        event->accept();
    } else {
        event->ignore();
    }
}

KanbanView::KanbanView(QWidget *parent)
    : QWidget(parent)
    , m_model(nullptr)
    , m_groupMode(GroupByStatus)
{
    setupUI();
}

void KanbanView::setupUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(10, 10, 10, 10);
    mainLayout->setSpacing(10);

    QWidget *columnContainer = new QWidget(this);
    m_columnLayout = new QHBoxLayout(columnContainer);
    m_columnLayout->setSpacing(10);
    m_columnLayout->setContentsMargins(0, 0, 0, 0);

    mainLayout->addWidget(columnContainer);

    refreshColumns();
}

void KanbanView::setGroupMode(GroupMode mode)
{
    if (m_groupMode != mode) {
        m_groupMode = mode;
        refreshColumns();
    }
}

void KanbanView::refreshColumns()
{
    qDeleteAll(m_columns);
    m_columns.clear();
    qDeleteAll(m_filters);
    m_filters.clear();

    QLayoutItem *item;
    while ((item = m_columnLayout->takeAt(0)) != nullptr) {
        if (item->widget()) {
            delete item->widget();
        }
        delete item;
    }

    if (m_groupMode == GroupByStatus) {
        createColumn("待办", 0, "#3498db");
        createColumn("进行中", 1, "#e67e22");
        createColumn("已完成", 2, "#2ecc71");
        createColumn("已延期", 3, "#e74c3c");
    } else {
        createColumn("紧急", 0, "#FF4444");
        createColumn("重要", 1, "#FF9900");
        createColumn("普通", 2, "#4CAF50");
        createColumn("不急", 3, "#9E9E9E");
    }

    if (m_model) {
        setModel(m_model);
    }
}

KanbanColumn* KanbanView::createColumn(const QString &title, int value, const QString &color)
{
    QWidget *columnWidget = new QWidget(this);
    columnWidget->setObjectName("kanbanColumn");
    columnWidget->setStyleSheet(QString("#kanbanColumn { border-top: 3px solid %1; }").arg(color));

    QVBoxLayout *layout = new QVBoxLayout(columnWidget);
    layout->setContentsMargins(0, 0, 0, 0);

    QLabel *header = new QLabel(title, columnWidget);
    header->setAlignment(Qt::AlignCenter);
    header->setStyleSheet("font-weight: bold; font-size: 14px; padding: 8px; color: #888;");
    layout->addWidget(header);

    KanbanColumn *list = new KanbanColumn(value, columnWidget);
    layout->addWidget(list);

    m_columnLayout->addWidget(columnWidget);
    m_columns.append(list);

    return list;
}

void KanbanView::setModel(TaskModel *model)
{
    m_model = model;
    if (!m_model) return;

    qDeleteAll(m_filters);
    m_filters.clear();

    for (KanbanColumn *col : m_columns) {
        TaskFilterModel *filter = new TaskFilterModel(this);
        filter->setSourceModel(model);

        if (m_groupMode == GroupByStatus) {
            filter->setFilterMode(TaskFilterModel::FilterStatus);
            filter->setFilterStatus(col->getValue());
            filter->setFilterPriority(-1);
        } else {
            filter->setFilterMode(TaskFilterModel::FilterAll);
            filter->setFilterPriority(col->getValue());
            filter->setFilterStatus(-1);
        }

        col->setModel(filter);
        m_filters.append(filter);

        connect(col, &KanbanColumn::taskDropped, this, [this](int taskId, int newValue){
            QVariantMap data;
            if (m_groupMode == GroupByStatus) {
                data["status"] = newValue;
            } else {
                data["priority"] = newValue;
            }
            m_model->updateTask(taskId, data);
        });

        connect(col, &KanbanColumn::taskDoubleClicked, this, &KanbanView::editTaskRequested);
    }
}
</file>

<file path="views/kanbanview.h">
#ifndef KANBANVIEW_H
#define KANBANVIEW_H

#include <QWidget>
#include <QListView>
#include <QStyledItemDelegate>

class TaskModel;
class TaskFilterModel;
class QHBoxLayout;

class KanbanDelegate : public QStyledItemDelegate
{
    Q_OBJECT
public:
    explicit KanbanDelegate(QObject *parent = nullptr);
    void paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const override;
    QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const override;
};

class KanbanColumn : public QListView
{
    Q_OBJECT
public:
    explicit KanbanColumn(int value, QWidget *parent = nullptr);
    int getValue() const { return m_value; }

protected:
    void dragEnterEvent(QDragEnterEvent *event) override;
    void dragMoveEvent(QDragMoveEvent *event) override;
    void dropEvent(QDropEvent *event) override;
    void startDrag(Qt::DropActions supportedActions) override;

signals:
    void taskDropped(int taskId, int newValue);
    void taskDoubleClicked(int taskId);

private:
    int m_value;
};

class KanbanView : public QWidget
{
    Q_OBJECT
public:
    enum GroupMode { GroupByStatus, GroupByPriority };

    explicit KanbanView(QWidget *parent = nullptr);
    void setModel(TaskModel *model);
    void setGroupMode(GroupMode mode);
    GroupMode getGroupMode() const { return m_groupMode; }

signals:
    void editTaskRequested(int taskId);

private:
    TaskModel *m_model;
    class QHBoxLayout *m_columnLayout;
    QList<KanbanColumn*> m_columns;
    QList<TaskFilterModel*> m_filters;
    GroupMode m_groupMode;

    void setupUI();
    KanbanColumn* createColumn(const QString &title, int value, const QString &color);
    void refreshColumns();
};

#endif // KANBANVIEW_H
</file>

<file path="widgets/tagwidget.cpp">
#include "tagwidget.h"
#include <QHBoxLayout>
#include <QPushButton>
#include <QPainter>
#include <QDebug>
#include <QCryptographicHash>
#include <QStyleOptionButton>

class TagButton : public QPushButton {
public:
    TagButton(const QString &text, QWidget *parent = nullptr) : QPushButton(text, parent) {
        setMouseTracking(true);
        setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
    }

protected:
    void enterEvent(QEnterEvent *event) override {
        m_isHovered = true;
        update();
        QPushButton::enterEvent(event);
    }

    void leaveEvent(QEvent *event) override {
        m_isHovered = false;
        update();
        QPushButton::leaveEvent(event);
    }

    void paintEvent(QPaintEvent *event) override {
        Q_UNUSED(event);
        QPainter painter(this);
        painter.setRenderHint(QPainter::Antialiasing);

        QColor bgColor = property("tagColor").value<QColor>();
        if (!bgColor.isValid()) bgColor = QColor("#657896");

        if (m_isHovered) {
            bgColor = QColor("#FF6B6B");
        }

        painter.setPen(Qt::NoPen);
        painter.setBrush(bgColor);
        painter.drawRoundedRect(rect(), 4, 4);

        painter.setPen(Qt::white);
        QFont font = painter.font();
        font.setPointSize(10);
        painter.setFont(font);

        painter.drawText(rect(), Qt::AlignCenter, text());
    }

private:
    bool m_isHovered = false;
};

TagWidget::TagWidget(QWidget *parent)
    : QWidget(parent)
    , m_layout(new QHBoxLayout(this))
{
    setupUI();
}

void TagWidget::setupUI()
{
    m_layout->setContentsMargins(0, 0, 0, 0);
    m_layout->setSpacing(8);
    m_layout->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);
    setFixedHeight(30);
}

void TagWidget::addTag(const QString &name, const QString &color)
{
    if (name.isEmpty() || hasTag(name)) {
        return;
    }

    QPushButton *tagButton = createTagButton(name, color);
    m_tagButtons.append(tagButton);
    m_layout->addWidget(tagButton);

    emit tagAdded(name);
}

void TagWidget::addAvailableTag(const QString &name, const QString &color)
{
    QVariantMap tag;
    tag["name"] = name;
    tag["color"] = color;
    m_availableTags.append(tag);
}

void TagWidget::removeTag(const QString &name)
{
    for (int i = 0; i < m_tagButtons.size(); ++i) {
        if (m_tagButtons[i]->text() == name) {
            QPushButton *button = m_tagButtons.takeAt(i);
            m_layout->removeWidget(button);
            button->deleteLater();
            emit tagRemoved(name);
            break;
        }
    }
}

void TagWidget::clearTags()
{
    for (QPushButton *button : m_tagButtons) {
        m_layout->removeWidget(button);
        button->deleteLater();
    }
    m_tagButtons.clear();
}

QList<QVariantMap> TagWidget::getTags() const
{
    QList<QVariantMap> tags;
    for (QPushButton *button : m_tagButtons) {
        QVariantMap tag;
        tag["name"] = button->text();
        tag["color"] = button->property("tagColor").value<QColor>().name();
        tags.append(tag);
    }
    return tags;
}

bool TagWidget::hasTag(const QString &name) const
{
    for (QPushButton *button : m_tagButtons) {
        if (button->text() == name) {
            return true;
        }
    }
    return false;
}

QPushButton* TagWidget::createTagButton(const QString &name, const QString &color)
{
    TagButton *button = new TagButton(name, this);

    QString finalColor = color;
    for (const QVariantMap &tag : m_availableTags) {
        if (tag["name"].toString() == name) {
            finalColor = tag["color"].toString();
            break;
        }
    }

    if (finalColor == "#657896") {
        finalColor = generateColor(name);
    }

    button->setProperty("tagColor", QColor(finalColor));
    button->setFixedHeight(26);

    QFont font = button->font();
    font.setPointSize(10);
    QFontMetrics fm(font);
    int textWidth = fm.horizontalAdvance(name);
    int padding = 24;
    button->setFixedWidth(textWidth + padding);

    button->setCursor(Qt::PointingHandCursor);
    button->setToolTip(QString("点击移除标签: %1").arg(name));

    connect(button, &QPushButton::clicked, this, &TagWidget::onTagButtonClicked);

    return button;
}

void TagWidget::onTagButtonClicked()
{
    QPushButton *button = qobject_cast<QPushButton*>(sender());
    if (button) {
        removeTag(button->text());
    }
}

void TagWidget::updateLayout()
{
    m_layout->update();
    update();
}

void TagWidget::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event);
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);
}

QString TagWidget::generateColor(const QString &text)
{
    // 预定义莫兰迪色盘
    static const QStringList palette = {
        "#C96A6A", // 柔和砖红
        "#D69E68", // 大地橙
        "#7FA882", // 鼠尾草绿
        "#8C949E", // 冷灰
        "#7696B3", // 钢蓝
        "#B48EAD", // 莫兰迪紫
        "#88C0D0", // 北欧蓝
        "#81A1C1", // 冰河蓝
        "#BF616A", // 浆果红
        "#EBCB8B"  // 麦穗黄
    };

    QCryptographicHash hash(QCryptographicHash::Md5);
    hash.addData(text.toUtf8());
    QByteArray result = hash.result();

    unsigned char index = static_cast<unsigned char>(result[0]);
    return palette[index % palette.size()];
}
</file>

<file path="dialogs/taskdialog.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TaskDialog</class>
 <widget class="QDialog" name="TaskDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>500</width>
    <height>540</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>任务编辑</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGroupBox" name="groupBoxBasic">
     <property name="title">
      <string>基本信息</string>
     </property>
     <layout class="QFormLayout" name="formLayout">
      <item row="0" column="0">
       <widget class="QLabel" name="labelTitle">
        <property name="text">
         <string>标题:</string>
        </property>
       </widget>
      </item>
      <item row="0" column="1">
       <widget class="QLineEdit" name="lineEditTitle">
        <property name="placeholderText">
         <string>请输入任务标题</string>
        </property>
       </widget>
      </item>
      <item row="1" column="0">
       <widget class="QLabel" name="labelCategory">
        <property name="text">
         <string>分类:</string>
        </property>
       </widget>
      </item>
      <item row="2" column="0">
       <widget class="QLabel" name="labelPriority">
        <property name="text">
         <string>优先级:</string>
        </property>
       </widget>
      </item>
      <item row="2" column="1">
       <widget class="QWidget" name="widgetPriority" native="true">
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <property name="spacing">
          <number>10</number>
         </property>
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
        </layout>
       </widget>
      </item>
      <item row="3" column="0">
       <widget class="QLabel" name="labelStatus">
        <property name="text">
         <string>状态:</string>
        </property>
       </widget>
      </item>
      <item row="3" column="1">
       <widget class="QWidget" name="widgetStatus" native="true">
        <layout class="QHBoxLayout" name="horizontalLayout_3">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
        </layout>
       </widget>
      </item>
      <item row="1" column="1">
       <widget class="QComboBox" name="comboBoxCategory">
        <property name="placeholderText">
         <string>请选择分类</string>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxTime">
     <property name="title">
      <string>时间安排</string>
     </property>
     <layout class="QGridLayout" name="gridLayout">
      <item row="0" column="0">
       <widget class="QLabel" name="labelStartTime">
        <property name="text">
         <string>开始时间:</string>
        </property>
       </widget>
      </item>
      <item row="0" column="1">
       <widget class="QDateTimeEdit" name="dateTimeEditStart">
        <property name="calendarPopup">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item row="1" column="0">
       <widget class="QLabel" name="labelDeadline">
        <property name="text">
         <string>截止时间:</string>
        </property>
       </widget>
      </item>
      <item row="1" column="1">
       <widget class="QDateTimeEdit" name="dateTimeEditDeadline">
        <property name="calendarPopup">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item row="2" column="0">
       <widget class="QLabel" name="labelRemind">
        <property name="text">
         <string>提醒时间:</string>
        </property>
       </widget>
      </item>
      <item row="2" column="1">
       <widget class="QDateTimeEdit" name="dateTimeEditRemind">
        <property name="calendarPopup">
         <bool>true</bool>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxTags">
     <property name="title">
      <string>标签管理</string>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout_2">
      <property name="spacing">
       <number>4</number>
      </property>
      <item>
       <widget class="QLabel" name="labelSelectedTags">
        <property name="styleSheet">
         <string>color: #888888; font-size: 11px;</string>
        </property>
        <property name="text">
         <string>已选标签 (点击移除，滚轮横向查看):</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QScrollArea" name="scrollAreaSelectedTags">
        <property name="minimumSize">
         <size>
          <width>0</width>
          <height>30</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>30</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Shape::NoFrame</enum>
        </property>
        <property name="verticalScrollBarPolicy">
         <enum>Qt::ScrollBarPolicy::ScrollBarAlwaysOff</enum>
        </property>
        <property name="horizontalScrollBarPolicy">
         <enum>Qt::ScrollBarPolicy::ScrollBarAlwaysOff</enum>
        </property>
        <property name="widgetResizable">
         <bool>true</bool>
        </property>
        <widget class="QWidget" name="scrollAreaWidgetContentsSelected">
         <property name="geometry">
          <rect>
           <x>0</x>
           <y>0</y>
           <width>466</width>
           <height>30</height>
          </rect>
         </property>
         <layout class="QHBoxLayout" name="horizontalLayout_SelectedTags">
          <property name="leftMargin">
           <number>0</number>
          </property>
          <property name="topMargin">
           <number>0</number>
          </property>
          <property name="rightMargin">
           <number>0</number>
          </property>
          <property name="bottomMargin">
           <number>0</number>
          </property>
          <item>
           <widget class="QWidget" name="widgetTags" native="true">
            <layout class="QHBoxLayout" name="horizontalLayout_TagWidgetContainer">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
            </layout>
           </widget>
          </item>
          <item>
           <spacer name="horizontalSpacer_Selected">
            <property name="orientation">
             <enum>Qt::Orientation::Horizontal</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>40</width>
              <height>20</height>
             </size>
            </property>
           </spacer>
          </item>
         </layout>
        </widget>
       </widget>
      </item>
      <item>
       <widget class="QLabel" name="labelExistingTags">
        <property name="styleSheet">
         <string>color: #888888; font-size: 11px;</string>
        </property>
        <property name="text">
         <string>已有标签 (点击添加，滚轮横向查看):</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QScrollArea" name="scrollAreaExistingTags">
        <property name="minimumSize">
         <size>
          <width>0</width>
          <height>30</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>30</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Shape::StyledPanel</enum>
        </property>
        <property name="frameShadow">
         <enum>QFrame::Shadow::Sunken</enum>
        </property>
        <property name="verticalScrollBarPolicy">
         <enum>Qt::ScrollBarPolicy::ScrollBarAlwaysOff</enum>
        </property>
        <property name="horizontalScrollBarPolicy">
         <enum>Qt::ScrollBarPolicy::ScrollBarAlwaysOff</enum>
        </property>
        <property name="widgetResizable">
         <bool>true</bool>
        </property>
        <widget class="QWidget" name="scrollAreaWidgetContentsExisting">
         <property name="geometry">
          <rect>
           <x>0</x>
           <y>0</y>
           <width>464</width>
           <height>28</height>
          </rect>
         </property>
         <layout class="QHBoxLayout" name="horizontalLayout_ExistingTags">
          <property name="leftMargin">
           <number>5</number>
          </property>
          <property name="topMargin">
           <number>0</number>
          </property>
          <property name="rightMargin">
           <number>5</number>
          </property>
          <property name="bottomMargin">
           <number>0</number>
          </property>
         </layout>
        </widget>
       </widget>
      </item>
      <item>
       <layout class="QHBoxLayout" name="horizontalLayout">
        <item>
         <widget class="QLineEdit" name="lineEditNewTag">
          <property name="placeholderText">
           <string>输入新标签，用逗号分隔</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="pushButtonAddTag">
          <property name="text">
           <string>添加标签</string>
          </property>
         </widget>
        </item>
       </layout>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="groupBoxDescription">
     <property name="title">
      <string>详细描述</string>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout_4">
      <item>
       <widget class="QTextEdit" name="textEditDescription">
        <property name="enabled">
         <bool>true</bool>
        </property>
        <property name="minimumSize">
         <size>
          <width>0</width>
          <height>40</height>
         </size>
        </property>
        <property name="placeholderText">
         <string>请输入任务详细描述...</string>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Orientation::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::StandardButton::Cancel|QDialogButtonBox::StandardButton::Save</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
</file>

<file path="dialogs/taskdialog.cpp">
#include "taskdialog.h"
#include "ui_taskdialog.h"
#include "widgets/prioritywidget.h"
#include "widgets/statuswidget.h"
#include "widgets/tagwidget.h"
#include "database/database.h"

#include <QPushButton>
#include <QMessageBox>
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>
#include <QOverload>
#include <QScrollArea>
#include <QHBoxLayout>
#include <QScrollBar>
#include <QWheelEvent>

TaskDialog::TaskDialog(QWidget *parent)
    : QDialog(parent)
    , ui(new Ui::TaskDialog)
    , m_isEditMode(false)
    , m_taskId(-1)
    , m_priorityWidget(nullptr)
    , m_statusWidget(nullptr)
    , m_tagWidget(nullptr)
    , m_existingTagsContainer(nullptr)
    , m_labelCreatedTime(nullptr)
    , m_labelCompletedTime(nullptr)
    , m_originalStatus(0)
{
    ui->setupUi(this);
    setWindowTitle("创建新任务");
    setupUI();
    setupConnections();
}

TaskDialog::TaskDialog(const QVariantMap &taskData, QWidget *parent)
    : QDialog(parent)
    , ui(new Ui::TaskDialog)
    , m_isEditMode(true)
    , m_taskId(taskData.value("id", -1).toInt())
    , m_priorityWidget(nullptr)
    , m_statusWidget(nullptr)
    , m_tagWidget(nullptr)
    , m_existingTagsContainer(nullptr)
    , m_labelCreatedTime(nullptr)
    , m_labelCompletedTime(nullptr)
    , m_originalStatus(0)
{
    ui->setupUi(this);
    setWindowTitle(QString("编辑任务: %1").arg(taskData.value("title").toString()));
    setupUI();
    setupConnections();
    populateData(taskData);
}

TaskDialog::~TaskDialog()
{
    delete ui;
}

void TaskDialog::setupUI()
{
    setModal(true);
    setWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint);

    ui->textEditDescription->setMaximumHeight(16777215);
    ui->textEditDescription->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    this->resize(500, 580);

    m_priorityWidget = new PriorityWidget(this);
    m_statusWidget = new StatusWidget(this);

    ui->widgetPriority->layout()->addWidget(m_priorityWidget);
    ui->widgetStatus->layout()->addWidget(m_statusWidget);

    m_tagWidget = new TagWidget(this);
    ui->widgetTags->layout()->addWidget(m_tagWidget);

    ui->scrollAreaSelectedTags->installEventFilter(this);
    ui->scrollAreaExistingTags->installEventFilter(this);
    ui->lineEditNewTag->installEventFilter(this);
    ui->scrollAreaWidgetContentsExisting->layout()->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);

    initDateTimeEdits();
    loadCategories();
    loadExistingTags();

    ui->buttonBox->button(QDialogButtonBox::Save)->setText("保存");
    ui->buttonBox->button(QDialogButtonBox::Cancel)->setText("取消");

    QFormLayout *formLayout = qobject_cast<QFormLayout*>(ui->groupBoxBasic->layout());
    if (formLayout) {
        m_labelCreatedTime = new QLabel("-", this);
        m_labelCompletedTime = new QLabel("-", this);

        QString style = "color: #888888; font-weight: bold;";
        m_labelCreatedTime->setStyleSheet("color: #657896;");
        m_labelCompletedTime->setStyleSheet("color: #657896;");
        QWidget *timeContainer = new QWidget(this);
        QHBoxLayout *timeLayout = new QHBoxLayout(timeContainer);
        timeLayout->setContentsMargins(0, 0, 0, 0);
        timeLayout->setSpacing(10);
        timeLayout->addWidget(new QLabel("创建于:", this));
        timeLayout->addWidget(m_labelCreatedTime);
        timeLayout->addStretch(1);
        timeLayout->addWidget(new QLabel("完成于:", this));
        timeLayout->addWidget(m_labelCompletedTime);
        timeLayout->addStretch(1);
        formLayout->addRow(timeContainer);
    }
}

void TaskDialog::setupConnections()
{
    connect(ui->buttonBox, &QDialogButtonBox::accepted, this, &TaskDialog::onSaveClicked);
    connect(ui->buttonBox, &QDialogButtonBox::rejected, this, &TaskDialog::onCancelClicked);
    connect(ui->pushButtonAddTag, &QPushButton::clicked, this, &TaskDialog::onAddTagClicked);
}

void TaskDialog::initDateTimeEdits()
{
    QDateTime now = QDateTime::currentDateTime();
    QDateTime tomorrow = now.addDays(1);

    ui->dateTimeEditStart->setDateTime(now);
    ui->dateTimeEditStart->setMinimumDateTime(now.addYears(-1));
    ui->dateTimeEditStart->setDisplayFormat("yyyy-MM-dd HH:mm");

    ui->dateTimeEditDeadline->setDateTime(tomorrow);
    ui->dateTimeEditDeadline->setMinimumDateTime(now);
    ui->dateTimeEditDeadline->setDisplayFormat("yyyy-MM-dd HH:mm");

    ui->dateTimeEditRemind->setDateTime(tomorrow.addSecs(-3600));
    ui->dateTimeEditRemind->setMinimumDateTime(now);
    ui->dateTimeEditRemind->setDisplayFormat("yyyy-MM-dd HH:mm");
}

void TaskDialog::loadCategories()
{
    ui->comboBoxCategory->clear();
    ui->comboBoxCategory->addItem("请选择分类", -1);

    QSqlQuery query(Database::instance().getDatabase());
    query.prepare("SELECT id, name, color FROM task_categories ORDER BY name");

    if (query.exec()) {
        while (query.next()) {
            int id = query.value("id").toInt();
            QString name = query.value("name").toString();
            QString color = query.value("color").toString();

            ui->comboBoxCategory->addItem(name, id);
            int index = ui->comboBoxCategory->count() - 1;

            QPixmap pixmap(16, 16);
            pixmap.fill(QColor(color));
            ui->comboBoxCategory->setItemIcon(index, QIcon(pixmap));
        }
    }

    if (ui->comboBoxCategory->count() > 1) {
        ui->comboBoxCategory->setCurrentIndex(1);
    }
}

void TaskDialog::loadExistingTags()
{
    QLayout *containerLayout = ui->scrollAreaWidgetContentsExisting->layout();

    QLayoutItem *item;
    while ((item = containerLayout->takeAt(0)) != nullptr) {
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }

    QSqlQuery query(Database::instance().getDatabase());
    query.prepare("SELECT name, color FROM task_tags ORDER BY name");

    if (query.exec()) {
        while (query.next()) {
            QString name = query.value("name").toString();
            QString color = query.value("color").toString();

            if (m_tagWidget) {
                m_tagWidget->addAvailableTag(name, color);
            }

            addExistingTagButton(name, color);
        }
    }
    static_cast<QHBoxLayout*>(containerLayout)->addStretch();
}

void TaskDialog::populateData(const QVariantMap &taskData)
{
    ui->lineEditTitle->setText(taskData.value("title").toString());
    ui->textEditDescription->setPlainText(taskData.value("description").toString());

    int categoryId = taskData.value("category_id").toInt();
    for (int i = 0; i < ui->comboBoxCategory->count(); ++i) {
        if (ui->comboBoxCategory->itemData(i).toInt() == categoryId) {
            ui->comboBoxCategory->setCurrentIndex(i);
            break;
        }
    }

    if (m_priorityWidget) {
        m_priorityWidget->setPriority(taskData.value("priority", 2).toInt());
    }

    if (m_statusWidget) {
        m_originalStatus = taskData.value("status", 0).toInt();
        m_statusWidget->setStatus(m_originalStatus);
    }

    QDateTime startTime = taskData.value("start_time").toDateTime();
    if (startTime.isValid()) {
        ui->dateTimeEditStart->setDateTime(startTime);
    }

    QDateTime deadline = taskData.value("deadline").toDateTime();
    if (deadline.isValid()) {
        ui->dateTimeEditDeadline->setDateTime(deadline);
    }

    QDateTime remindTime = taskData.value("remind_time").toDateTime();
    if (remindTime.isValid()) {
        ui->dateTimeEditRemind->setDateTime(remindTime);
    }
    m_originalCreatedTime = taskData.value("created_at").toDateTime();
    if (m_labelCreatedTime) {
        m_labelCreatedTime->setText(m_originalCreatedTime.isValid() ?
                                        m_originalCreatedTime.toString("yyyy-MM-dd HH:mm:ss") : "-");
    }

    m_originalCompletedTime = taskData.value("completed_at").toDateTime();
    if (m_labelCompletedTime) {
        if (m_originalCompletedTime.isValid()) {
            m_labelCompletedTime->setText(m_originalCompletedTime.toString("yyyy-MM-dd HH:mm:ss"));
        } else {
            m_labelCompletedTime->setText("-");
        }
    }

    QVariantList tagNames = taskData.value("tag_names").toList();
    QVariantList tagColors = taskData.value("tag_colors").toList();

    if (m_tagWidget && !tagNames.isEmpty()) {
        for (int i = 0; i < tagNames.size(); ++i) {
            QString tagName = tagNames.at(i).toString();
            QString tagColor = i < tagColors.size() ? tagColors.at(i).toString() : "#657896";
            m_tagWidget->addTag(tagName, tagColor);
        }
    }
}

QVariantMap TaskDialog::getTaskData() const
{
    QVariantMap taskData;

    taskData["title"] = ui->lineEditTitle->text().trimmed();
    taskData["description"] = ui->textEditDescription->toPlainText();
    taskData["category_id"] = ui->comboBoxCategory->currentData().toInt();

    if (taskData["category_id"].toInt() == -1) {
        taskData["category_id"] = 1;
    }

    if (m_priorityWidget) {
        taskData["priority"] = m_priorityWidget->getPriority();
    } else {
        taskData["priority"] = 2;
    }

    int currentStatus = 0;
    if (m_statusWidget) {
        currentStatus = m_statusWidget->getStatus();
        taskData["status"] = currentStatus;
    }

    if (currentStatus == 2) {
        if (m_originalStatus != 2) {
            taskData["completed_at"] = QDateTime::currentDateTime();
        } else {
            taskData["completed_at"] = m_originalCompletedTime;
        }
    } else {
        taskData["completed_at"] = QVariant();
    }

    if (m_isEditMode) {
        taskData["created_at"] = m_originalCreatedTime;
    }

    taskData["start_time"] = ui->dateTimeEditStart->dateTime();
    taskData["deadline"] = ui->dateTimeEditDeadline->dateTime();
    taskData["remind_time"] = ui->dateTimeEditRemind->dateTime();

    taskData["is_reminded"] = false;
    taskData["is_deleted"] = false;

    if (m_tagWidget) {
        QList<QVariantMap> tags = m_tagWidget->getTags();
        QVariantList tagNames, tagColors;

        for (const QVariantMap &tag : tags) {
            tagNames.append(tag["name"]);
            tagColors.append(tag["color"]);
        }

        taskData["tag_names"] = tagNames;
        taskData["tag_colors"] = tagColors;
    }

    return taskData;
}

bool TaskDialog::validateInput()
{
    QString title = ui->lineEditTitle->text().trimmed();
    if (title.isEmpty()) {
        QMessageBox::warning(this, "输入错误", "任务标题不能为空！");
        ui->lineEditTitle->setFocus();
        return false;
    }

    int categoryId = ui->comboBoxCategory->currentData().toInt();
    if (categoryId == -1) {
        QMessageBox::warning(this, "输入错误", "请选择任务分类！");
        ui->comboBoxCategory->setFocus();
        return false;
    }

    QDateTime startTime = ui->dateTimeEditStart->dateTime();
    QDateTime deadline = ui->dateTimeEditDeadline->dateTime();

    if (startTime.isValid() && deadline.isValid() && startTime > deadline) {
        QMessageBox::warning(this, "输入错误", "开始时间不能晚于截止时间！");
        return false;
    }

    return true;
}

void TaskDialog::onSaveClicked()
{
    if (!validateInput()) {
        return;
    }

    accept();
}

void TaskDialog::onCancelClicked()
{
    reject();
}

void TaskDialog::onAddTagClicked()
{
    QString newTagText = ui->lineEditNewTag->text().trimmed();
    if (newTagText.isEmpty()) {
        return;
    }

    QStringList newTags = newTagText.replace("，", ",").split(",", Qt::SkipEmptyParts);

    for (QString &tag : newTags) {
        tag = tag.trimmed();

        if (tag.length() > 6) {
            QMessageBox::warning(this, "格式错误", QString("标签 '%1' 过长，请限制在6个字以内").arg(tag));
            continue;
        }

        if (!tag.isEmpty()) {
            QString color = TagWidget::generateColor(tag);
            if (m_tagWidget) {
                m_tagWidget->addTag(tag, color);
            }
            if (Database::instance().addTag(tag, color)) {
                QLayout *layout = ui->scrollAreaWidgetContentsExisting->layout();
                QLayoutItem *spacer = layout->takeAt(layout->count() - 1);

                addExistingTagButton(tag, color);

                if (spacer) {
                    layout->addItem(spacer);
                } else {
                    static_cast<QHBoxLayout*>(layout)->addStretch();
                }
            }
        }
    }

    ui->lineEditNewTag->clear();
}

void TaskDialog::showEvent(QShowEvent *event)
{
    QDialog::showEvent(event);

    if (ui->lineEditTitle->text().isEmpty()) {
        ui->lineEditTitle->setFocus();
    }
}

QVariantMap TaskDialog::createTask(const QVariantMap &initialData, QWidget *parent)
{
    TaskDialog dialog(parent);
    if (!initialData.isEmpty()) {
        dialog.populateData(initialData);
    }

    if (dialog.exec() == QDialog::Accepted) {
        return dialog.getTaskData();
    }

    return QVariantMap();
}

QVariantMap TaskDialog::editTask(const QVariantMap &taskData, QWidget *parent)
{
    TaskDialog dialog(taskData, parent);

    if (dialog.exec() == QDialog::Accepted) {
        return dialog.getTaskData();
    }

    return QVariantMap();
}

bool TaskDialog::eventFilter(QObject *obj, QEvent *event)
{
    if (obj == ui->lineEditNewTag && event->type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);
        if (keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Enter) {
            if (!ui->lineEditNewTag->text().trimmed().isEmpty()) {
                onAddTagClicked();
            }
            else {
                onSaveClicked();
            }
            return true;
        }
    }

    if (event->type() == QEvent::Wheel) {
        QScrollArea *scrollArea = qobject_cast<QScrollArea*>(obj);
        if (scrollArea && (scrollArea == ui->scrollAreaSelectedTags || scrollArea == ui->scrollAreaExistingTags)) {
            QWheelEvent *wheelEvent = static_cast<QWheelEvent*>(event);

            int delta = wheelEvent->angleDelta().y();

            if (delta != 0) {
                QScrollBar *bar = scrollArea->horizontalScrollBar();
                bar->setValue(bar->value() - delta);
                return true;
            }
        }
    }
    return QDialog::eventFilter(obj, event);
}

void TaskDialog::addExistingTagButton(const QString &name, const QString &color)
{
    QPushButton *tagBtn = new QPushButton(name, ui->scrollAreaWidgetContentsExisting);
    tagBtn->setCursor(Qt::PointingHandCursor);
    tagBtn->setObjectName("existingTagBtn");

    tagBtn->setFixedHeight(24);

    QFont font = tagBtn->font();
    if (font.pointSize() < 9) font.setPointSize(9);

    QFontMetrics fm(font);
    int textWidth = fm.horizontalAdvance(name);
    int padding = 24;
    tagBtn->setFixedWidth(textWidth + padding);

    QString dynamicStyle = QString(
                               "QPushButton#existingTagBtn {"
                               "  border: 1px solid %1;"
                               "}"
                               "QPushButton#existingTagBtn:hover {"
                               "  background-color: %1;"
                               "  border: 1px solid %1;"
                               "}"
                               ).arg(color);

    tagBtn->setStyleSheet(dynamicStyle);

    connect(tagBtn, &QPushButton::clicked, this, [this, name, color]() {
        if (m_tagWidget) {
            m_tagWidget->addTag(name, color);
        }
    });

    ui->scrollAreaWidgetContentsExisting->layout()->addWidget(tagBtn);
}
</file>

<file path="models/taskmodel.h">
#ifndef TASKMODEL_H
#define TASKMODEL_H

#include <QAbstractTableModel>
#include <QSqlDatabase>
#include <QList>
#include <QColor>
#include <QSqlRecord>
#include <QMimeData>
#include "taskitem.h"

class TaskModel : public QAbstractTableModel
{
    Q_OBJECT

public:
    enum TaskRole {
        IdRole = Qt::UserRole + 1,
        TitleRole,
        DescriptionRole,
        CategoryIdRole,
        CategoryNameRole,
        CategoryColorRole,
        PriorityRole,
        PriorityTextRole,
        PriorityColorRole,
        StatusRole,
        StatusTextRole,
        StatusColorRole,
        StartTimeRole,
        DeadlineRole,
        RemindTimeRole,
        IsRemindedRole,
        IsDeletedRole,
        CreatedAtRole,
        UpdatedAtRole,
        CompletedAtRole,
        TagIdsRole,
        TagNamesRole,
        TagColorsRole,
        IsOverdueRole
    };

    explicit TaskModel(QObject *parent = nullptr);
    ~TaskModel();

    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
    int columnCount(const QModelIndex &parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

    Qt::ItemFlags flags(const QModelIndex &index) const override;
    Qt::DropActions supportedDropActions() const override;
    Qt::DropActions supportedDragActions() const override;

    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole) override;
    QMap<int, QVariant> itemData(const QModelIndex &index) const override;

    QStringList mimeTypes() const override;
    QMimeData *mimeData(const QModelIndexList &indexes) const override;

    bool addTask(const QVariantMap &taskData);
    bool updateTask(int taskId, const QVariantMap &taskData);
    bool deleteTask(int taskId, bool softDelete = true);
    bool restoreTask(int taskId);
    QVariantMap getTask(int taskId) const;
    bool permanentDeleteTask(int taskId);

    void sort(int column, Qt::SortOrder order = Qt::AscendingOrder) override;

    QList<QVariantMap> getAllTasks(bool includeDeleted = false) const;
    QList<QVariantMap> getTasksByStatus(int status) const;
    QList<QVariantMap> getTasksByCategory(int categoryId) const;
    QList<QVariantMap> getTasksByTag(int tagId) const;
    QList<QVariantMap> getDeletedTasks() const;

    void refresh(bool showDeleted = false);

    static QMap<int, QString> getPriorityOptions();
    static QMap<int, QString> getStatusOptions();

    int getTaskCount(bool includeDeleted = false) const;
    int getCompletedCount() const;
    double getCompletionRate() const;
    int getDeletedTaskCount() const;

signals:
    void taskAdded(int taskId);
    void taskUpdated(int taskId);
    void taskDeleted(int taskId);
    void taskRestored(int taskId);
    void taskPermanentlyDeleted(int taskId);
    void refreshRequested(bool showDeleted);

private:
    QList<TaskItem> tasks;
    QSqlDatabase db;
    bool showingDeleted;

    QList<int> resolveTagIds(const QStringList &tagNames, const QStringList &tagColors);

    void loadTasks(bool includeDeleted = false);
    TaskItem loadTaskFromDb(int taskId) const;
    QList<int> loadTaskTags(int taskId) const;
    bool updateTaskTags(int taskId, const QList<int> &tagIds);
    QDateTime getCurrentTimestamp() const;
};

#endif // TASKMODEL_H
</file>

<file path="models/taskmodel.cpp">
#include "taskmodel.h"
#include "database/database.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QDebug>
#include <QMimeData>
#include <QDataStream>

static QSqlDatabase getDbConnection()
{
    QSqlDatabase db = Database::instance().getDatabase();
    if (!db.isOpen()) {
        Database::instance().ensureConnected();
        db = Database::instance().getDatabase();
    }
    return db;
}

TaskModel::TaskModel(QObject *parent)
    : QAbstractTableModel(parent)
    , showingDeleted(false)
{
    refresh(false);
}

TaskModel::~TaskModel()
{
}

int TaskModel::rowCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return tasks.size();
}

int TaskModel::columnCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return 8;
}

QVariant TaskModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid() || index.row() >= tasks.size())
        return QVariant();

    const TaskItem &task = tasks.at(index.row());

    switch (role) {
    case Qt::DisplayRole:
        switch (index.column()) {
        case 0: return task.id;
        case 1: return task.title;
        case 2: return task.categoryName;
        case 3: return task.priorityText();
        case 4: return task.statusText();
        case 5: return task.deadline.isValid() ? task.deadline.toString("yyyy-MM-dd HH:mm") : "-";
        case 6: return task.remindTime.isValid() ? task.remindTime.toString("yyyy-MM-dd HH:mm") : "-";
        case 7: {
            if (task.status == 2) {
                return task.completedAt.isValid() ? task.completedAt.toString("yyyy-MM-dd HH:mm") : "-";
            }
            return task.createdAt.isValid() ? task.createdAt.toString("yyyy-MM-dd HH:mm") : "-";
        }
        default: return QVariant();
        }

    case Qt::DecorationRole:
        if (index.column() == 3) return task.priorityColor();
        if (index.column() == 4) return task.statusColor();
        break;

    case Qt::ToolTipRole:
        return QString("描述: %1\n标签: %2")
            .arg(task.description)
            .arg(task.tagNames.join(", "));

    case Qt::TextAlignmentRole:
        return int(Qt::AlignCenter);

    case IdRole: return task.id;
    case TitleRole: return task.title;
    case DescriptionRole: return task.description;
    case CategoryIdRole: return task.categoryId;
    case CategoryNameRole: return task.categoryName;
    case CategoryColorRole: return task.categoryColor;
    case PriorityRole: return task.priority;
    case PriorityTextRole: return task.priorityText();
    case PriorityColorRole: return task.priorityColor();
    case StatusRole: return task.status;
    case StatusTextRole: return task.statusText();
    case StatusColorRole: return task.statusColor();
    case StartTimeRole: return task.startTime;
    case DeadlineRole: return task.deadline;
    case RemindTimeRole: return task.remindTime;
    case IsRemindedRole: return task.isReminded;
    case IsDeletedRole: return task.isDeleted;
    case CreatedAtRole: return task.createdAt;
    case UpdatedAtRole: return task.updatedAt;
    case CompletedAtRole: return task.completedAt;
    case TagIdsRole: return QVariant::fromValue(task.tagIds);
    case TagNamesRole: return QVariant::fromValue(task.tagNames);
    case TagColorsRole: return QVariant::fromValue(task.tagColors);
    case IsOverdueRole: return task.isOverdue();
    }

    return QVariant();
}

QVariant TaskModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (role != Qt::DisplayRole)
        return QVariant();

    if (orientation == Qt::Horizontal) {
        switch (section) {
        case 0: return "ID";
        case 1: return "标题";
        case 2: return "分类";
        case 3: return "优先级";
        case 4: return "状态";
        case 5: return "截止时间";
        case 6: return "提醒时间";
        case 7: return "创建/完成时间";
        default: return QVariant();
        }
    }
    return QVariant();
}

void TaskModel::sort(int column, Qt::SortOrder order)
{
    emit layoutAboutToBeChanged();
    std::sort(tasks.begin(), tasks.end(), [column, order](const TaskItem &a, const TaskItem &b) {
        bool asc = (order == Qt::AscendingOrder);
        switch (column) {
        case 0: return asc ? a.id < b.id : a.id > b.id;
        case 1: return asc ? a.title < b.title : a.title > b.title;
        case 2: return asc ? a.categoryName < b.categoryName : a.categoryName > b.categoryName;
        case 3: return asc ? a.priority < b.priority : a.priority > b.priority;
        case 4: return asc ? a.status < b.status : a.status > b.status;
        case 5: return asc ? a.deadline < b.deadline : a.deadline > b.deadline;
        case 6: return asc ? a.remindTime < b.remindTime : a.remindTime > b.remindTime;
        case 7: return asc ? a.createdAt < b.createdAt : a.createdAt > b.createdAt;
        default: return asc ? a.id < b.id : a.id > b.id;
        }
    });
    emit layoutChanged();
}

QList<int> TaskModel::resolveTagIds(const QStringList &tagNames, const QStringList &tagColors)
{
    QList<int> tagIds;
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return tagIds;

    for (int i = 0; i < tagNames.size(); ++i) {
        QString name = tagNames[i];
        QString color = (i < tagColors.size()) ? tagColors[i] : "#657896";
        QSqlQuery checkQuery(db);
        checkQuery.prepare("SELECT id FROM task_tags WHERE name = ?");
        checkQuery.addBindValue(name);
        if (checkQuery.exec() && checkQuery.next()) {
            tagIds.append(checkQuery.value(0).toInt());
        } else {
            QSqlQuery insertQuery(db);
            insertQuery.prepare("INSERT INTO task_tags (name, color) VALUES (?, ?)");
            insertQuery.addBindValue(name);
            insertQuery.addBindValue(color);
            if (insertQuery.exec()) {
                tagIds.append(insertQuery.lastInsertId().toInt());
            }
        }
    }
    return tagIds;
}

bool TaskModel::setData(const QModelIndex &index, const QVariant &value, int role)
{
    if (!index.isValid() || index.row() >= tasks.size()) return false;
    int taskId = tasks[index.row()].id;
    const TaskItem &currentItem = tasks[index.row()];
    QVariantMap taskData = currentItem.toVariantMap();
    bool changed = false;

    if (role == PriorityRole || (index.column() == 3 && role == Qt::EditRole)) {
        int newPriority = value.toInt();
        if (newPriority != currentItem.priority) {
            taskData["priority"] = newPriority;
            changed = true;
        }
    }
    else if (role == StatusRole || (index.column() == 4 && role == Qt::EditRole)) {
        int newStatus = value.toInt();
        if (newStatus != currentItem.status) {
            taskData["status"] = newStatus;
            if (newStatus == 2) taskData["completed_at"] = QDateTime::currentDateTime();
            else taskData["completed_at"] = QVariant();
            changed = true;
        }
    }
    if (changed) return updateTask(taskId, taskData);
    return false;
}

QMap<int, QVariant> TaskModel::itemData(const QModelIndex &index) const
{
    QMap<int, QVariant> map = QAbstractTableModel::itemData(index);
    if (index.isValid()) {
        map.insert(IdRole, data(index, IdRole));
    }
    return map;
}

Qt::ItemFlags TaskModel::flags(const QModelIndex &index) const
{
    if (!index.isValid())
        return Qt::NoItemFlags;

    Qt::ItemFlags flags = Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsDragEnabled | Qt::ItemIsDropEnabled;

    if (index.column() == 3 || index.column() == 4) {
        flags |= Qt::ItemIsEditable;
    }

    return flags;
}

Qt::DropActions TaskModel::supportedDropActions() const
{
    return Qt::CopyAction | Qt::MoveAction;
}

Qt::DropActions TaskModel::supportedDragActions() const
{
    return Qt::CopyAction | Qt::MoveAction;
}

QStringList TaskModel::mimeTypes() const
{
    return QStringList() << "application/x-task-id";
}

QMimeData *TaskModel::mimeData(const QModelIndexList &indexes) const
{
    QMimeData *mimeData = new QMimeData();
    QByteArray encodedData;
    QDataStream stream(&encodedData, QIODevice::WriteOnly);

    if (!indexes.isEmpty()) {
        const QModelIndex &index = indexes.first();
        if (index.isValid()) {
            int taskId = data(index, IdRole).toInt();
            stream << taskId;
        }
    }

    mimeData->setData("application/x-task-id", encodedData);
    return mimeData;
}

void TaskModel::refresh(bool showDeleted)
{
    showingDeleted = showDeleted;
    loadTasks(showDeleted);
}

void TaskModel::loadTasks(bool includeDeleted)
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return;

    beginResetModel();
    tasks.clear();

    QString queryStr = "SELECT t.*, c.name as category_name, c.color as category_color "
                       "FROM tasks t "
                       "LEFT JOIN task_categories c ON t.category_id = c.id ";
    if (!includeDeleted) queryStr += "WHERE t.is_deleted = 0 ";
    queryStr += "ORDER BY t.priority ASC, t.deadline ASC";

    QSqlQuery query(db);
    if (query.exec(queryStr)) {
        while (query.next()) {
            TaskItem task;
            task.id = query.value("id").toInt();
            task.title = query.value("title").toString();
            task.description = query.value("description").toString();
            task.categoryId = query.value("category_id").toInt();
            task.categoryName = query.value("category_name").toString();
            task.categoryColor = query.value("category_color").toString();
            task.priority = query.value("priority").toInt();
            task.status = query.value("status").toInt();
            task.startTime = query.value("start_time").toDateTime();
            task.deadline = query.value("deadline").toDateTime();
            task.remindTime = query.value("remind_time").toDateTime();
            task.isReminded = query.value("is_reminded").toBool();
            task.isDeleted = query.value("is_deleted").toBool();
            task.createdAt = query.value("created_at").toDateTime();
            task.updatedAt = query.value("updated_at").toDateTime();
            task.completedAt = query.value("completed_at").toDateTime();

            task.tagIds = loadTaskTags(task.id);
            for (int tagId : task.tagIds) {
                QSqlQuery tagQuery(db);
                tagQuery.prepare("SELECT name, color FROM task_tags WHERE id = ?");
                tagQuery.addBindValue(tagId);
                if (tagQuery.exec() && tagQuery.next()) {
                    task.tagNames.append(tagQuery.value("name").toString());
                    task.tagColors.append(tagQuery.value("color").toString());
                }
            }
            tasks.append(task);
        }
    }
    endResetModel();
}

TaskItem TaskModel::loadTaskFromDb(int taskId) const
{
    TaskItem task;
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return task;

    QSqlQuery query(db);
    query.prepare("SELECT t.*, c.name as category_name, c.color as category_color "
                  "FROM tasks t "
                  "LEFT JOIN task_categories c ON t.category_id = c.id "
                  "WHERE t.id = ?");
    query.addBindValue(taskId);

    if (query.exec() && query.next()) {
        task.id = query.value("id").toInt();
        task.title = query.value("title").toString();
        task.description = query.value("description").toString();
        task.categoryId = query.value("category_id").toInt();
        task.categoryName = query.value("category_name").toString();
        task.categoryColor = query.value("category_color").toString();
        task.priority = query.value("priority").toInt();
        task.status = query.value("status").toInt();
        task.startTime = query.value("start_time").toDateTime();
        task.deadline = query.value("deadline").toDateTime();
        task.remindTime = query.value("remind_time").toDateTime();
        task.isReminded = query.value("is_reminded").toBool();
        task.isDeleted = query.value("is_deleted").toBool();
        task.createdAt = query.value("created_at").toDateTime();
        task.updatedAt = query.value("updated_at").toDateTime();
        task.completedAt = query.value("completed_at").toDateTime();

        task.tagIds = loadTaskTags(taskId);
        for (int tagId : task.tagIds) {
            QSqlQuery tagQuery(db);
            tagQuery.prepare("SELECT name, color FROM task_tags WHERE id = ?");
            tagQuery.addBindValue(tagId);
            if (tagQuery.exec() && tagQuery.next()) {
                task.tagNames.append(tagQuery.value("name").toString());
                task.tagColors.append(tagQuery.value("color").toString());
            }
        }
    }
    return task;
}

bool TaskModel::addTask(const QVariantMap &taskData)
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return false;

    TaskItem task = TaskItem::fromVariantMap(taskData);
    task.createdAt = getCurrentTimestamp();
    task.updatedAt = task.createdAt;

    QStringList tagNames = taskData.value("tag_names").toStringList();
    QStringList tagColors = taskData.value("tag_colors").toStringList();
    task.tagIds = resolveTagIds(tagNames, tagColors);

    QSqlQuery query(db);
    QString sql = QString(
        "INSERT INTO tasks (title, description, category_id, priority, "
        "status, start_time, deadline, remind_time, is_reminded, is_deleted, "
        "created_at, updated_at, completed_at) "
        "VALUES (:title, :description, :category_id, :priority, "
        ":status, :start_time, :deadline, :remind_time, :is_reminded, :is_deleted, "
        ":created_at, :updated_at, :completed_at)"
        );

    query.prepare(sql);
    query.bindValue(":title", task.title);
    query.bindValue(":description", task.description);
    query.bindValue(":category_id", task.categoryId);
    query.bindValue(":priority", task.priority);
    query.bindValue(":status", task.status);
    query.bindValue(":start_time", task.startTime);
    query.bindValue(":deadline", task.deadline);
    query.bindValue(":remind_time", task.remindTime);
    query.bindValue(":is_reminded", task.isReminded);
    query.bindValue(":is_deleted", task.isDeleted);
    query.bindValue(":created_at", task.createdAt);
    query.bindValue(":updated_at", task.updatedAt);
    query.bindValue(":completed_at", task.completedAt);

    if (!query.exec()) return false;
    task.id = query.lastInsertId().toInt();

    if (!task.tagIds.isEmpty()) updateTaskTags(task.id, task.tagIds);

    refresh();
    emit taskAdded(task.id);
    return true;
}

bool TaskModel::updateTask(int taskId, const QVariantMap &taskData)
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return false;

    TaskItem task = TaskItem::fromVariantMap(taskData);
    task.id = taskId;
    task.updatedAt = getCurrentTimestamp();

    if (task.status == 2 && !task.completedAt.isValid()) {
        task.completedAt = QDateTime::currentDateTime();
    }

    QStringList tagNames = taskData.value("tag_names").toStringList();
    QStringList tagColors = taskData.value("tag_colors").toStringList();
    task.tagIds = resolveTagIds(tagNames, tagColors);

    QSqlQuery query(db);
    query.prepare("UPDATE tasks SET title = ?, description = ?, category_id = ?, "
                  "priority = ?, status = ?, start_time = ?, deadline = ?, "
                  "remind_time = ?, is_reminded = ?, is_deleted = ?, "
                  "updated_at = ?, completed_at = ? WHERE id = ?");

    query.addBindValue(task.title);
    query.addBindValue(task.description);
    query.addBindValue(task.categoryId);
    query.addBindValue(task.priority);
    query.addBindValue(task.status);
    query.addBindValue(task.startTime);
    query.addBindValue(task.deadline);
    query.addBindValue(task.remindTime);
    query.addBindValue(task.isReminded);
    query.addBindValue(task.isDeleted);
    query.addBindValue(task.updatedAt);
    query.addBindValue(task.completedAt);
    query.addBindValue(taskId);

    if (!query.exec()) return false;

    QSqlQuery deleteQuery(db);
    deleteQuery.prepare("DELETE FROM task_tag_relations WHERE task_id = ?");
    deleteQuery.addBindValue(taskId);
    deleteQuery.exec();

    if (!task.tagIds.isEmpty()) updateTaskTags(taskId, task.tagIds);

    refresh();
    emit taskUpdated(taskId);
    return true;
}

bool TaskModel::deleteTask(int taskId, bool softDelete)
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return false;

    QSqlQuery query(db);
    if (softDelete) {
        query.prepare("UPDATE tasks SET is_deleted = 1, updated_at = ? WHERE id = ?");
        query.addBindValue(getCurrentTimestamp());
        query.addBindValue(taskId);
        if (!query.exec()) return false;
        refresh(showingDeleted);
        emit taskDeleted(taskId);
        return true;
    } else {
        return permanentDeleteTask(taskId);
    }
}

QList<QVariantMap> TaskModel::getDeletedTasks() const
{
    QList<QVariantMap> taskList;
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return taskList;

    QSqlQuery query(db);
    query.prepare("SELECT t.*, c.name as category_name, c.color as category_color "
                  "FROM tasks t "
                  "LEFT JOIN task_categories c ON t.category_id = c.id "
                  "WHERE t.is_deleted = 1 "
                  "ORDER BY t.updated_at DESC");

    if (query.exec()) {
        while (query.next()) {
            QVariantMap task;
            QSqlRecord record = query.record();
            for (int i = 0; i < record.count(); ++i) {
                task[record.fieldName(i)] = query.value(i);
            }
            int taskId = task["id"].toInt();
            QList<int> tagIds = loadTaskTags(taskId);
            QVariantList tagNames, tagColors;
            for (int tagId : tagIds) {
                QSqlQuery tagQuery(db);
                tagQuery.prepare("SELECT name, color FROM task_tags WHERE id = ?");
                tagQuery.addBindValue(tagId);
                if (tagQuery.exec() && tagQuery.next()) {
                    tagNames.append(tagQuery.value("name").toString());
                    tagColors.append(tagQuery.value("color").toString());
                }
            }
            task["tag_ids"] = QVariant::fromValue(tagIds);
            task["tag_names"] = tagNames;
            task["tag_colors"] = tagColors;
            taskList.append(task);
        }
    }
    return taskList;
}

int TaskModel::getDeletedTaskCount() const
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return 0;
    QSqlQuery query(db);
    query.prepare("SELECT COUNT(*) FROM tasks WHERE is_deleted = 1");
    if (query.exec() && query.next()) return query.value(0).toInt();
    return 0;
}

bool TaskModel::restoreTask(int taskId)
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return false;
    QSqlQuery query(db);
    query.prepare("UPDATE tasks SET is_deleted = 0, updated_at = ? WHERE id = ?");
    query.addBindValue(getCurrentTimestamp());
    query.addBindValue(taskId);
    if (!query.exec()) return false;
    if (showingDeleted) refresh(true);
    emit taskRestored(taskId);
    return true;
}

bool TaskModel::permanentDeleteTask(int taskId)
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return false;
    db.transaction();
    try {
        QSqlQuery deleteTagsQuery(db);
        deleteTagsQuery.prepare("DELETE FROM task_tag_relations WHERE task_id = ?");
        deleteTagsQuery.addBindValue(taskId);
        if (!deleteTagsQuery.exec()) { db.rollback(); return false; }

        QSqlQuery deleteTaskQuery(db);
        deleteTaskQuery.prepare("DELETE FROM tasks WHERE id = ?");
        deleteTaskQuery.addBindValue(taskId);
        if (!deleteTaskQuery.exec()) { db.rollback(); return false; }

        db.commit();
        refresh(showingDeleted);
        emit taskPermanentlyDeleted(taskId);
        return true;
    } catch (...) {
        db.rollback();
        return false;
    }
}

QVariantMap TaskModel::getTask(int taskId) const
{
    for (const TaskItem &task : tasks) {
        if (task.id == taskId) return task.toVariantMap();
    }
    TaskItem task = loadTaskFromDb(taskId);
    return task.toVariantMap();
}

QList<int> TaskModel::loadTaskTags(int taskId) const
{
    QList<int> tagIds;
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return tagIds;
    QSqlQuery query(db);
    query.prepare("SELECT tag_id FROM task_tag_relations WHERE task_id = ?");
    query.addBindValue(taskId);
    if (query.exec()) {
        while (query.next()) tagIds.append(query.value("tag_id").toInt());
    }
    return tagIds;
}

bool TaskModel::updateTaskTags(int taskId, const QList<int> &tagIds)
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return false;
    bool success = true;
    for (int tagId : tagIds) {
        QSqlQuery query(db);
        query.prepare("INSERT OR IGNORE INTO task_tag_relations (task_id, tag_id) VALUES (?, ?)");
        query.addBindValue(taskId);
        query.addBindValue(tagId);
        if (!query.exec()) success = false;
    }
    return success;
}

QList<QVariantMap> TaskModel::getAllTasks(bool includeDeleted) const
{
    QList<QVariantMap> taskList;
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return taskList;

    // 修复：增加 JOIN 语句以获取分类名称 category_name
    QString queryStr = "SELECT t.*, c.name as category_name FROM tasks t "
                       "LEFT JOIN task_categories c ON t.category_id = c.id ";

    if (!includeDeleted) queryStr += "WHERE t.is_deleted = 0 ";
    queryStr += "ORDER BY t.created_at DESC";

    QSqlQuery query(db);
    if (query.exec(queryStr)) {
        while (query.next()) {
            QVariantMap task;
            for (int i = 0; i < query.record().count(); ++i) {
                task[query.record().fieldName(i)] = query.value(i);
            }
            taskList.append(task);
        }
    }
    return taskList;
}

QList<QVariantMap> TaskModel::getTasksByStatus(int status) const
{
    QList<QVariantMap> taskList;
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return taskList;
    QSqlQuery query(db);
    query.prepare("SELECT * FROM tasks WHERE status = ? AND is_deleted = 0 ORDER BY deadline ASC");
    query.addBindValue(status);
    if (query.exec()) {
        while (query.next()) {
            QVariantMap task;
            for (int i = 0; i < query.record().count(); ++i) {
                task[query.record().fieldName(i)] = query.value(i);
            }
            taskList.append(task);
        }
    }
    return taskList;
}

QList<QVariantMap> TaskModel::getTasksByCategory(int categoryId) const
{
    QList<QVariantMap> taskList;
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return taskList;
    QSqlQuery query(db);
    query.prepare("SELECT * FROM tasks WHERE category_id = ? AND is_deleted = 0 ORDER BY created_at DESC");
    query.addBindValue(categoryId);
    if (query.exec()) {
        while (query.next()) {
            QVariantMap task;
            for (int i = 0; i < query.record().count(); ++i) {
                task[query.record().fieldName(i)] = query.value(i);
            }
            taskList.append(task);
        }
    }
    return taskList;
}

QList<QVariantMap> TaskModel::getTasksByTag(int tagId) const
{
    QList<QVariantMap> taskList;
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return taskList;
    QSqlQuery query(db);
    query.prepare("SELECT t.* FROM tasks t "
                  "JOIN task_tag_relations r ON t.id = r.task_id "
                  "WHERE r.tag_id = ? AND t.is_deleted = 0 "
                  "ORDER BY t.created_at DESC");
    query.addBindValue(tagId);
    if (query.exec()) {
        while (query.next()) {
            QVariantMap task;
            for (int i = 0; i < query.record().count(); ++i) {
                task[query.record().fieldName(i)] = query.value(i);
            }
            taskList.append(task);
        }
    }
    return taskList;
}

QMap<int, QString> TaskModel::getPriorityOptions()
{
    return {{0, "紧急"}, {1, "重要"}, {2, "普通"}, {3, "不急"}};
}

QMap<int, QString> TaskModel::getStatusOptions()
{
    return {{0, "待办"}, {1, "进行中"}, {2, "已完成"}, {3, "已延期"}};
}

int TaskModel::getTaskCount(bool includeDeleted) const
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return 0;
    QString queryStr = "SELECT COUNT(*) FROM tasks ";
    if (!includeDeleted) queryStr += "WHERE is_deleted = 0";
    QSqlQuery query(db);
    if (query.exec(queryStr) && query.next()) return query.value(0).toInt();
    return 0;
}

int TaskModel::getCompletedCount() const
{
    QSqlDatabase db = getDbConnection();
    if (!db.isOpen()) return 0;
    QSqlQuery query(db);
    query.prepare("SELECT COUNT(*) FROM tasks WHERE status = 2 AND is_deleted = 0");
    if (query.exec() && query.next()) return query.value(0).toInt();
    return 0;
}

double TaskModel::getCompletionRate() const
{
    int total = getTaskCount();
    if (total == 0) return 0.0;
    int completed = getCompletedCount();
    return static_cast<double>(completed) / total * 100.0;
}

QDateTime TaskModel::getCurrentTimestamp() const
{
    return QDateTime::currentDateTime();
}
</file>

<file path="mainwindow.h">
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QSystemTrayIcon>
#include <QMenu>
#include <QTabWidget>
#include <QStatusBar>
#include <QVBoxLayout>
#include <QTableView>
#include <QSplitter>

class TaskModel;
class InspirationModel;
class WatermarkWidget;
class TaskDialog;
class RecycleBinDialog;
class TaskFilterModel;
class TaskTableView;

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

protected:
    void resizeEvent(QResizeEvent *event) override;

private slots:
    void onTrayIconActivated(QSystemTrayIcon::ActivationReason reason);
    void showMainWindow();
    void quitApplication();
    void onAddTaskClicked();
    void onEditTaskClicked();
    void onDeleteTaskClicked();
    void onRefreshTasksClicked();
    void onTaskDoubleClicked(const QModelIndex &index);
     void onRecycleBinClicked();

    void onQuickRecordClicked();
     void onCalendarDateClicked(const QDate &date);

    void onTaskRestored(int taskId);
    void onTaskPermanentlyDeleted(int taskId);

    void onTagManagerClicked();
    void onEditTask(int taskId);

    void onCalendarShowInspirations(const QDate &date);
    void onCalendarShowTasks(const QDate &date);

private:
    QSystemTrayIcon *trayIcon;
    QMenu *trayMenu;
    QTabWidget *tabWidget;
    QStatusBar *statusBarWidget;

    TaskModel *taskModel;
    InspirationModel *inspirationModel;
    class StatisticModel *statisticModel;

    QTableView *taskTableView;
    QSplitter *taskSplitter;
    TaskTableView *uncompletedTableView;
    TaskTableView *completedTableView;

    class KanbanView *kanbanView;
    class CalendarView *calendarView;
    class StatisticView *statisticView;
    class QStackedWidget *viewStack;

    class QComboBox *filterCategoryCombo;
    class QComboBox *filterPriorityCombo;
    class QLineEdit *searchEdit;
    class QPushButton *kanbanGroupBtn;

    RecycleBinDialog *recycleBinDialog;

    TaskFilterModel *uncompletedProxyModel;
    TaskFilterModel *completedProxyModel;

    void setupSystemTray();
    void setupUI();
    void createWatermark();
    void loadStyleSheet();
    void setupConnections();

    void createTaskTab();
    void createInspirationTab();
    void createStatisticTab();
    void createSettingTab();

    void updateStatusBar(const QString &message);
    int getSelectedTaskId() const;
};
#endif // MAINWINDOW_H
</file>

<file path="mainwindow.cpp">
#include "mainwindow.h"
#include "database/database.h"
#include "widgets/watermarkwidget.h"
#include "models/taskmodel.h"
#include "models/inspirationmodel.h"
#include "dialogs/taskdialog.h"
#include "dialogs/recyclebindialog.h"
#include "dialogs/tagmanagerdialog.h"
#include "models/taskfiltermodel.h"
#include "widgets/comboboxdelegate.h"
#include "views/kanbanview.h"
#include "views/calenderview.h"
#include "views/tasktableview.h"
#include "views/inspirationview.h"
#include "dialogs/inspirationdialog.h"
#include "views/statisticview.h"
#include "models/statisticmodel.h"

#include <QStackedWidget>
#include <QComboBox>
#include <QApplication>
#include <QScreen>
#include <QFile>
#include <QStyle>
#include <QDebug>
#include <QLabel>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QTableView>
#include <QHeaderView>
#include <QMessageBox>
#include <QShortcut>
#include <QMenuBar>
#include <QMenu>
#include <QSplitter>
#include <QLineEdit>
#include <QButtonGroup>
#include <QShortcut>
#include <QKeySequence>
#include <QListWidget>
#include <QMouseEvent>
#include <QTableWidget>


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , taskModel(nullptr)
    , inspirationModel(nullptr)
    , taskTableView(nullptr)
    , recycleBinDialog(nullptr)
{
    Database::instance().initDatabase();

    loadStyleSheet();

    QScreen *screen = QApplication::primaryScreen();
    QRect screenGeometry = screen->geometry();
    int width = screenGeometry.width() * 3 / 4;
    int height = screenGeometry.height() * 3 / 4;
    int x = (screenGeometry.width() - width) / 2;
    int y = (screenGeometry.height() - height) / 2;

    setGeometry(x, y, width, height);
    setWindowTitle("个人工作与任务管理系统");

    taskModel = new TaskModel(this);
    inspirationModel = new InspirationModel(this);
    statisticModel = new StatisticModel(this);

    recycleBinDialog = new RecycleBinDialog(this);
    recycleBinDialog->setTaskModel(taskModel);

    createWatermark();
    setupSystemTray();
    setupUI();
    setupConnections();

    if (recycleBinDialog && taskModel) {
        recycleBinDialog->setTaskModel(taskModel);
    }
}

MainWindow::~MainWindow()
{
}

void MainWindow::setupUI()
{
    QWidget *centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);

    QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);
    mainLayout->setContentsMargins(10, 10, 10, 0);
    mainLayout->setSpacing(0);

    QLabel *titleLabel = new QLabel("个人工作与任务管理系统", centralWidget);
    titleLabel->setObjectName("titleLabel");
    titleLabel->setAlignment(Qt::AlignCenter);
    mainLayout->addWidget(titleLabel);

    tabWidget = new QTabWidget(centralWidget);
    tabWidget->setObjectName("mainTabWidget");

    createTaskTab();
    createInspirationTab();
    createStatisticTab();
    createSettingTab();

    mainLayout->addWidget(tabWidget);

    statusBarWidget = new QStatusBar(this);
    setStatusBar(statusBarWidget);
    updateStatusBar(QString("就绪 | 任务总数: %1 | 已完成: %2 | 回收站: %3")
                        .arg(taskModel->getTaskCount())
                        .arg(taskModel->getCompletedCount())
                        .arg(taskModel->getDeletedTaskCount()));

    QLabel *infoLabel = new QLabel("开发者：谢静蕾 | 学号：2023414300117", centralWidget);
    infoLabel->setObjectName("infoLabel");
    infoLabel->setAlignment(Qt::AlignRight);
    mainLayout->addWidget(infoLabel);
}

void MainWindow::createTaskTab()
{
    QWidget *taskTab = new QWidget();
    QVBoxLayout *layout = new QVBoxLayout(taskTab);

    QHBoxLayout *toolbarLayout = new QHBoxLayout();

    QPushButton *addBtn = new QPushButton("添加", taskTab);
    addBtn->setObjectName("addTaskBtn");
    addBtn->setIcon(QIcon(":/icons/add_icon.png"));

    QPushButton *editBtn = new QPushButton("编辑", taskTab);
    editBtn->setObjectName("editTaskBtn");
    editBtn->setIcon(QIcon(":/icons/edit_icon.png"));

    QPushButton *deleteBtn = new QPushButton("删除", taskTab);
    deleteBtn->setObjectName("deleteTaskBtn");
    deleteBtn->setIcon(QIcon(":/icons/delete_icon.png"));

    toolbarLayout->addWidget(addBtn);
    toolbarLayout->addWidget(editBtn);
    toolbarLayout->addWidget(deleteBtn);

    toolbarLayout->addSpacing(10);
    toolbarLayout->addWidget(new QLabel("过滤:", taskTab));
    toolbarLayout->addSpacing(-20);
    filterCategoryCombo = new QComboBox(taskTab);
    filterCategoryCombo->setObjectName("filterCategoryCombo");
    filterCategoryCombo->addItem("所有分类", -1);
    filterCategoryCombo->addItem("灵感记录✨", -2);

    QList<QVariantMap> cats = Database::instance().getAllCategories();
    for(const auto &cat : cats) {
        filterCategoryCombo->addItem(cat["name"].toString(), cat["id"]);
    }

    filterPriorityCombo = new QComboBox(taskTab);
    filterPriorityCombo->setObjectName("filterPriorityCombo");
    filterPriorityCombo->addItem("所有优先级", -1);
    filterPriorityCombo->addItem("紧急", 0);
    filterPriorityCombo->addItem("重要", 1);
    filterPriorityCombo->addItem("普通", 2);
    filterPriorityCombo->addItem("不急", 3);

    searchEdit = new QLineEdit(taskTab);
    searchEdit->setPlaceholderText("搜索任务...");
    searchEdit->setFixedWidth(210);
    toolbarLayout->addSpacing(20);
    toolbarLayout->addWidget(filterCategoryCombo);
    toolbarLayout->addWidget(filterPriorityCombo);
    toolbarLayout->addWidget(searchEdit);

    toolbarLayout->addStretch();

    QPushButton *recycleBinBtn = new QPushButton("回收站", taskTab);
    recycleBinBtn->setObjectName("taskRecycleBinBtn");
    recycleBinBtn->setIcon(QIcon(":/icons/recycle_icon.png"));

    QPushButton *tagManagerBtn = new QPushButton("标签管理", taskTab);
    tagManagerBtn->setObjectName("taskTagManagerBtn");
    tagManagerBtn->setIcon(QIcon(":/icons/edit_icon.png"));

    QPushButton *refreshBtn = new QPushButton("刷新", taskTab);
    refreshBtn->setObjectName("taskRefreshBtn");
    refreshBtn->setIcon(QIcon(":/icons/refresh_icon.png"));

    toolbarLayout->addWidget(recycleBinBtn);
    toolbarLayout->addWidget(tagManagerBtn);
    toolbarLayout->addWidget(refreshBtn);

    viewStack = new QStackedWidget(taskTab);

    QWidget *listViewWidget = new QWidget();
    QVBoxLayout *listLayout = new QVBoxLayout(listViewWidget);
    listLayout->setContentsMargins(0,0,0,0);

    taskSplitter = new QSplitter(Qt::Vertical, listViewWidget);
    taskSplitter->setHandleWidth(1);
    taskSplitter->setStyleSheet("QSplitter::handle { background-color: #3d3d3d; }");

    uncompletedProxyModel = new TaskFilterModel(this);
    uncompletedProxyModel->setSourceModel(taskModel);
    uncompletedProxyModel->setFilterMode(TaskFilterModel::FilterUncompleted);

    completedProxyModel = new TaskFilterModel(this);
    completedProxyModel->setSourceModel(taskModel);
    completedProxyModel->setFilterMode(TaskFilterModel::FilterCompleted);

    uncompletedTableView = new TaskTableView(taskSplitter);
    uncompletedTableView->setObjectName("uncompletedTableView");
    uncompletedTableView->setModel(uncompletedProxyModel);

    connect(uncompletedTableView, &TaskTableView::editTaskRequested,
            this, &MainWindow::onEditTask);

    QWidget *bottomContainer = new QWidget(taskSplitter);
    QVBoxLayout *bottomLayout = new QVBoxLayout(bottomContainer);
    bottomLayout->setContentsMargins(0, 0, 0, 0);
    bottomLayout->setSpacing(0);

    QPushButton *separatorBtn = new QPushButton(bottomContainer);
    separatorBtn->setObjectName("completedSeparatorBtn");
    separatorBtn->setCursor(Qt::PointingHandCursor);
    separatorBtn->setFixedHeight(7);
    separatorBtn->setFlat(true);

    completedTableView = new TaskTableView(bottomContainer);
    completedTableView->setObjectName("completedTableView");
    completedTableView->setModel(completedProxyModel);

    connect(completedTableView, &TaskTableView::editTaskRequested,
            this, &MainWindow::onEditTask);

    completedTableView->horizontalHeader()->hide();
    completedTableView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    completedTableView->setFrameShape(QFrame::NoFrame);

    connect(separatorBtn, &QPushButton::clicked, [this]() {
        bool isVisible = completedTableView->horizontalHeader()->isVisible();
        completedTableView->horizontalHeader()->setVisible(!isVisible);
    });

    bottomLayout->addWidget(separatorBtn);
    bottomLayout->addWidget(completedTableView);

    taskSplitter->addWidget(uncompletedTableView);
    taskSplitter->addWidget(bottomContainer);
    taskSplitter->setStretchFactor(0, 7);
    taskSplitter->setStretchFactor(1, 3);

    listLayout->addWidget(taskSplitter);

    kanbanView = new KanbanView(taskTab);
    kanbanView->setModel(taskModel);

    connect(kanbanView, &KanbanView::editTaskRequested, this, &MainWindow::onEditTask);

    calendarView = new CalendarView(taskTab);
    calendarView->setTaskModel(taskModel);
    calendarView->setInspirationModel(inspirationModel);
    viewStack->addWidget(listViewWidget);
    viewStack->addWidget(kanbanView);
    viewStack->addWidget(calendarView);

    connect(calendarView, &CalendarView::showInspirations, this, &MainWindow::onCalendarShowInspirations);
    connect(calendarView, &CalendarView::showTasks, this, &MainWindow::onCalendarShowTasks);

    QHBoxLayout *bottomBarLayout = new QHBoxLayout();

    QWidget *leftContainer = new QWidget(taskTab);
    leftContainer->setFixedWidth(110);
    QHBoxLayout *leftContainerLayout = new QHBoxLayout(leftContainer);
    leftContainerLayout->setContentsMargins(0, 0, 0, 0);

    kanbanGroupBtn = new QPushButton("分组: 状态", leftContainer);
    kanbanGroupBtn->setObjectName("kanbanGroupBtn");
    kanbanGroupBtn->setCursor(Qt::PointingHandCursor);
    kanbanGroupBtn->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    kanbanGroupBtn->setVisible(false);

    leftContainerLayout->addWidget(kanbanGroupBtn);

    connect(kanbanGroupBtn, &QPushButton::clicked, this, [this](){
        if (!kanbanView) return;
        if (kanbanView->getGroupMode() == KanbanView::GroupByStatus) {
            kanbanView->setGroupMode(KanbanView::GroupByPriority);
            kanbanGroupBtn->setText("分组: 优先级");
        } else {
            kanbanView->setGroupMode(KanbanView::GroupByStatus);
            kanbanGroupBtn->setText("分组: 状态");
        }
    });

    QButtonGroup *viewGroup = new QButtonGroup(taskTab);
    QPushButton *listViewBtn = new QPushButton("列表视图", taskTab);
    listViewBtn->setCheckable(true);
    listViewBtn->setChecked(true);
    listViewBtn->setObjectName("listViewBtn");

    QPushButton *kanbanViewBtn = new QPushButton("看板视图", taskTab);
    kanbanViewBtn->setCheckable(true);
    kanbanViewBtn->setObjectName("kanbanViewBtn");

    QPushButton *calendarViewBtn = new QPushButton("日历视图", taskTab);
    calendarViewBtn->setCheckable(true);
    calendarViewBtn->setObjectName("calendarViewBtn");

    viewGroup->addButton(listViewBtn, 0);
    viewGroup->addButton(kanbanViewBtn, 1);
    viewGroup->addButton(calendarViewBtn, 2);

    QHBoxLayout *centerBtnLayout = new QHBoxLayout();
    centerBtnLayout->addWidget(listViewBtn);
    centerBtnLayout->addWidget(kanbanViewBtn);
    centerBtnLayout->addWidget(calendarViewBtn);

    QWidget *dummyRight = new QWidget(taskTab);
    dummyRight->setFixedWidth(110);

    bottomBarLayout->addWidget(leftContainer);
    bottomBarLayout->addStretch();
    bottomBarLayout->addLayout(centerBtnLayout);
    bottomBarLayout->addStretch();
    bottomBarLayout->addWidget(dummyRight);

    connect(viewGroup, &QButtonGroup::idClicked, this, [this](int id){
        viewStack->setCurrentIndex(id);
        if (kanbanGroupBtn) {
            kanbanGroupBtn->setVisible(id == 1);
        }
    });

    auto updateFilters = [this]() {
        int catId = filterCategoryCombo->currentData().toInt();
        int pri = filterPriorityCombo->currentData().toInt();
        QString text = searchEdit->text();

        if (catId == -2) {
            uncompletedProxyModel->setFilterCategory(-999);
            completedProxyModel->setFilterCategory(-999);
        } else {
            uncompletedProxyModel->setFilterCategory(catId);
            completedProxyModel->setFilterCategory(catId);
        }

        uncompletedProxyModel->setFilterPriority(pri);
        uncompletedProxyModel->setFilterText(text);

        completedProxyModel->setFilterPriority(pri);
        completedProxyModel->setFilterText(text);

        if (calendarView) {
            calendarView->setFilter(catId, pri);
        }
    };

    connect(filterCategoryCombo, &QComboBox::currentIndexChanged, this, updateFilters);
    connect(filterPriorityCombo, &QComboBox::currentIndexChanged, this, updateFilters);
    connect(searchEdit, &QLineEdit::textChanged, this, updateFilters);

    layout->addLayout(toolbarLayout);
    layout->addWidget(viewStack, 1);
    layout->addLayout(bottomBarLayout);

    tabWidget->addTab(taskTab, "任务管理");
}

void MainWindow::setupSystemTray()
{
    trayIcon = new QSystemTrayIcon(this);
    QIcon trayIconResource(":/icons/tray_icon.png");
    if (trayIconResource.isNull()) {
        qDebug() << "托盘图标加载失败，使用默认图标";
        trayIcon->setIcon(QIcon::fromTheme("calendar"));
    } else {
        trayIcon->setIcon(trayIconResource);
    }

    trayMenu = new QMenu(this);

    // 1. 添加任务
    QAction *addTaskAction = new QAction(QIcon(":/icons/add_icon.png"), "添加任务", this);
    connect(addTaskAction, &QAction::triggered, this, &MainWindow::onAddTaskClicked);
    trayMenu->addAction(addTaskAction);

    // 2. 记录灵感
    QAction *addInspirationAction = new QAction(QIcon(":/icons/edit_icon.png"), "记录灵感", this);
    connect(addInspirationAction, &QAction::triggered, this, &MainWindow::onQuickRecordClicked);
    trayMenu->addAction(addInspirationAction);

    trayMenu->addSeparator();

    QAction *showAction = new QAction("显示主窗口", this);
    connect(showAction, &QAction::triggered, this, &MainWindow::showMainWindow);
    trayMenu->addAction(showAction);

    trayMenu->addSeparator();

    QAction *quitAction = new QAction("退出", this);
    connect(quitAction, &QAction::triggered, this, &MainWindow::quitApplication);
    trayMenu->addAction(quitAction);

    trayIcon->setContextMenu(trayMenu);
    trayIcon->show();

    connect(trayIcon, &QSystemTrayIcon::activated,
            this, &MainWindow::onTrayIconActivated);
}

void MainWindow::createInspirationTab()
{
    QWidget *inspirationTab = new QWidget();
    QVBoxLayout *layout = new QVBoxLayout(inspirationTab);
    layout->setContentsMargins(0, 0, 0, 0);

    InspirationView *inspirationView = new InspirationView(inspirationTab);
    inspirationView->setModel(inspirationModel);
    inspirationView->setTaskModel(taskModel);

    connect(inspirationView, &InspirationView::showInspirationsRequested, this, &MainWindow::onCalendarShowInspirations);
    connect(inspirationView, &InspirationView::showTasksRequested, this, &MainWindow::onCalendarShowTasks);

    layout->addWidget(inspirationView);

    tabWidget->addTab(inspirationTab, "灵感记录");
}

void MainWindow::createStatisticTab()
{
    QWidget *statisticTab = new QWidget();
    QVBoxLayout *layout = new QVBoxLayout(statisticTab);
    layout->setContentsMargins(0, 0, 0, 0);

    statisticView = new StatisticView(statisticTab);
    statisticView->setModels(taskModel, statisticModel);

    layout->addWidget(statisticView);

    tabWidget->addTab(statisticTab, "统计分析");

    // 切换到统计标签页时刷新数据
    connect(tabWidget, &QTabWidget::currentChanged, this, [this](int index) {
        if (tabWidget->tabText(index) == "统计分析") {
            statisticView->refresh();
        }
    });
}

void MainWindow::createSettingTab()
{
    QWidget *settingTab = new QWidget();
    QVBoxLayout *layout = new QVBoxLayout(settingTab);

    QLabel *settingLabel = new QLabel("系统设置将显示在这里", settingTab);
    settingLabel->setObjectName("settingLabel");
    settingLabel->setAlignment(Qt::AlignCenter);
    settingLabel->setMinimumHeight(400);

    layout->addWidget(settingLabel);

    tabWidget->addTab(settingTab, "系统设置");
}

void MainWindow::setupConnections()
{
    QPushButton *addBtn = findChild<QPushButton*>("addTaskBtn");
    if (addBtn) {
        connect(addBtn, &QPushButton::clicked, this, &MainWindow::onAddTaskClicked);
    }

    QPushButton *editBtn = findChild<QPushButton*>("editTaskBtn");
    if (editBtn) {
        connect(editBtn, &QPushButton::clicked, this, &MainWindow::onEditTaskClicked);
    }

    QPushButton *deleteBtn = findChild<QPushButton*>("deleteTaskBtn");
    if (deleteBtn) {
        connect(deleteBtn, &QPushButton::clicked, this, &MainWindow::onDeleteTaskClicked);
    }

    QPushButton *quickRecordBtn = findChild<QPushButton*>("quickRecordBtn");
    if (quickRecordBtn) {
        connect(quickRecordBtn, &QPushButton::clicked, this, &MainWindow::onQuickRecordClicked);
    }

    QPushButton *recycleBinBtn = findChild<QPushButton*>("taskRecycleBinBtn");
    if (recycleBinBtn) {
        connect(recycleBinBtn, &QPushButton::clicked, this, &MainWindow::onRecycleBinClicked);
    }

    QPushButton *tagManagerBtn = findChild<QPushButton*>("taskTagManagerBtn");
    if (tagManagerBtn) {
        connect(tagManagerBtn, &QPushButton::clicked, this, &MainWindow::onTagManagerClicked);
    }

    QPushButton *refreshBtn = findChild<QPushButton*>("taskRefreshBtn");
    if (refreshBtn) {
        connect(refreshBtn, &QPushButton::clicked, this, &MainWindow::onRefreshTasksClicked);
    }

    new QShortcut(QKeySequence(Qt::CTRL | Qt::SHIFT | Qt::Key_R), this, SLOT(onRecycleBinClicked()));

    if (taskTableView) {
        connect(taskTableView, &QTableView::doubleClicked, this, &MainWindow::onTaskDoubleClicked);
    }

    new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_N), this, SLOT(onAddTaskClicked()));
    new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_E), this, SLOT(onEditTaskClicked()));
    new QShortcut(QKeySequence(Qt::Key_Delete), this, SLOT(onDeleteTaskClicked()));
    new QShortcut(QKeySequence(Qt::Key_F5), this, SLOT(onRefreshTasksClicked()));
    new QShortcut(QKeySequence(Qt::CTRL | Qt::SHIFT | Qt::Key_I), this, SLOT(onQuickRecordClicked()));

    if (taskModel) {
        connect(taskModel, &TaskModel::taskAdded, this, [this](int taskId) {
            Q_UNUSED(taskId);
            updateStatusBar(QString("任务添加成功 | 任务总数: %1 | 已完成: %2 | 回收站: %3")
                                .arg(taskModel->getTaskCount())
                                .arg(taskModel->getCompletedCount())
                                .arg(taskModel->getDeletedTaskCount()));
        });

        connect(taskModel, &TaskModel::taskUpdated, this, [this](int taskId) {
            Q_UNUSED(taskId);
            updateStatusBar(QString("任务更新成功 | 任务总数: %1 | 已完成: %2 | 回收站: %3")
                                .arg(taskModel->getTaskCount())
                                .arg(taskModel->getCompletedCount())
                                .arg(taskModel->getDeletedTaskCount()));
        });

        connect(taskModel, &TaskModel::taskDeleted, this, [this](int taskId) {
            Q_UNUSED(taskId);
            updateStatusBar(QString("任务已移到回收站 | 任务总数: %1 | 已完成: %2 | 回收站: %3")
                                .arg(taskModel->getTaskCount())
                                .arg(taskModel->getCompletedCount())
                                .arg(taskModel->getDeletedTaskCount()));
        });

    }
}
void MainWindow::onRecycleBinClicked()
{
    if (recycleBinDialog) {
        recycleBinDialog->refreshDeletedTasks();
        recycleBinDialog->exec();
    }
}
void MainWindow::onTaskRestored(int taskId)
{
    Q_UNUSED(taskId);
    updateStatusBar(QString("任务已恢复 | 任务总数: %1 | 已完成: %2 | 回收站: %3")
                        .arg(taskModel->getTaskCount())
                        .arg(taskModel->getCompletedCount())
                        .arg(taskModel->getDeletedTaskCount()));

    if (taskModel) {
        taskModel->refresh(false);
    }
}

void MainWindow::onTaskPermanentlyDeleted(int taskId)
{
    Q_UNUSED(taskId);
    updateStatusBar(QString("任务已永久删除 | 任务总数: %1 | 已完成: %2 | 回收站: %3")
                        .arg(taskModel->getTaskCount())
                        .arg(taskModel->getCompletedCount())
                        .arg(taskModel->getDeletedTaskCount()));
}

void MainWindow::onAddTaskClicked()
{
    TaskDialog dialog(this);

    if (dialog.exec() == QDialog::Accepted) {
        QVariantMap taskData = dialog.getTaskData();

        if (taskModel->addTask(taskData)) {
            updateStatusBar("新任务添加成功");
        } else {
            QMessageBox::warning(this, "错误", "添加任务失败");
        }
    }
}

void MainWindow::onEditTaskClicked()
{
    int taskId = getSelectedTaskId();
    if (taskId == -1) {
        QMessageBox::warning(this, "提示", "请先选择一个任务");
        return;
    }

    QVariantMap taskData = taskModel->getTask(taskId);
    if (taskData.isEmpty()) {
        QMessageBox::warning(this, "错误", "获取任务信息失败");
        return;
    }

    TaskDialog dialog(taskData, this);

    if (dialog.exec() == QDialog::Accepted) {
        QVariantMap updatedData = dialog.getTaskData();

        if (taskModel->updateTask(taskId, updatedData)) {
            updateStatusBar("任务更新成功");
        } else {
            QMessageBox::warning(this, "错误", "更新任务失败");
        }
    }
}

void MainWindow::onEditTask(int taskId)
{
    if (taskId <= 0) return;

    QVariantMap taskData = taskModel->getTask(taskId);
    if (taskData.isEmpty()) {
        QMessageBox::warning(this, "错误", "获取任务信息失败");
        return;
    }

    TaskDialog dialog(taskData, this);

    if (dialog.exec() == QDialog::Accepted) {
        QVariantMap updatedData = dialog.getTaskData();

        if (taskModel->updateTask(taskId, updatedData)) {
            updateStatusBar("任务更新成功");
        } else {
            QMessageBox::warning(this, "错误", "更新任务失败");
        }
    }
}

void MainWindow::onDeleteTaskClicked()
{
    int taskId = getSelectedTaskId();
    if (taskId == -1) {
        QMessageBox::warning(this, "提示", "请先选择一个任务");
        return;
    }

    QVariantMap taskData = taskModel->getTask(taskId);
    QString taskTitle = taskData.value("title").toString();

    QMessageBox::StandardButton reply;
    reply = QMessageBox::question(this, "确认删除",
                                  QString("确定要将任务 '%1' 移动到回收站吗？\n(可以在回收站中恢复或永久删除)")
                                      .arg(taskTitle),
                                  QMessageBox::Yes | QMessageBox::No);

    if (reply == QMessageBox::Yes) {
        if (taskModel->deleteTask(taskId, true)) {
            updateStatusBar(QString("任务 '%1' 已移动到回收站").arg(taskTitle));
        } else {
            QMessageBox::warning(this, "错误", "删除任务失败");
        }
    }
}

void MainWindow::onRefreshTasksClicked()
{
    if (taskModel) {
        taskModel->refresh();
        updateStatusBar("任务列表已刷新");
    }
}

void MainWindow::onTagManagerClicked()
{
    TagManagerDialog dialog(this);
    dialog.exec();
    if (taskModel) {
        taskModel->refresh();
    }
}

void MainWindow::onTaskDoubleClicked(const QModelIndex &index)
{
    Q_UNUSED(index);
    onEditTaskClicked();
}

int MainWindow::getSelectedTaskId() const
{
    TaskTableView *activeView = nullptr;

    if (uncompletedTableView->hasFocus() || uncompletedTableView->selectionModel()->hasSelection()) {
        activeView = uncompletedTableView;
    } else if (completedTableView->hasFocus() || completedTableView->selectionModel()->hasSelection()) {
        activeView = completedTableView;
    }

    if (!activeView || !activeView->selectionModel()->hasSelection()) {
        return -1;
    }

    QModelIndex proxyIndex = activeView->selectionModel()->selectedRows().first();

    QSortFilterProxyModel *proxy = qobject_cast<QSortFilterProxyModel*>(activeView->model());
    if (!proxy) return -1;

    QModelIndex sourceIndex = proxy->mapToSource(proxyIndex);

    return taskModel->data(sourceIndex, TaskModel::IdRole).toInt();
}

void MainWindow::onQuickRecordClicked()
{
    InspirationDialog dialog(this);
    if (dialog.exec() == QDialog::Accepted) {
        QVariantMap data = dialog.getData();
        if (inspirationModel->addInspiration(data["content"].toString(), data["tags"].toString())) {
            updateStatusBar("灵感记录成功！");
        } else {
            QMessageBox::warning(this, "错误", "记录失败");
        }
    }
}

void MainWindow::onCalendarDateClicked(const QDate &date)
{
    QList<QVariantMap> inspirations = inspirationModel->getInspirationsByDate(date);

    if (inspirations.isEmpty()) {
        return;
    }

    QDialog dlg(this);
    dlg.setWindowTitle(QString("灵感记录 - %1").arg(date.toString("MM月dd日")));
    dlg.resize(400, 500);
    dlg.setWindowFlags(dlg.windowFlags() & ~Qt::WindowContextHelpButtonHint);

    QVBoxLayout *layout = new QVBoxLayout(&dlg);

    QListWidget *listWidget = new QListWidget(&dlg);
    listWidget->setAlternatingRowColors(true);
    listWidget->setStyleSheet("QListWidget { border: 1px solid #3d3d3d; background-color: #2d2d2d; } "
                              "QListWidget::item { padding: 10px; border-bottom: 1px solid #3d3d3d; }");

    for (const QVariantMap &data : inspirations) {
        QString timeStr = data["created_at"].toDateTime().toString("HH:mm");
        QString content = data["content"].toString();
        QString tags = data["tags"].toString();

        QString displayText = QString("[%1] %2").arg(timeStr, content);
        if (!tags.isEmpty()) {
            displayText += QString("\n标签: %1").arg(tags);
        }

        QListWidgetItem *item = new QListWidgetItem(displayText);
        listWidget->addItem(item);
    }

    layout->addWidget(listWidget);

    QPushButton *closeBtn = new QPushButton("关闭", &dlg);
    connect(closeBtn, &QPushButton::clicked, &dlg, &QDialog::accept);
    layout->addWidget(closeBtn, 0, Qt::AlignRight);

    dlg.exec();
}

void MainWindow::updateStatusBar(const QString &message)
{
    if (statusBarWidget) {
        statusBarWidget->showMessage(message);
    }
}

void MainWindow::createWatermark()
{
    WatermarkWidget *watermark = new WatermarkWidget("谢静蕾 2023414300117", this);

    connect(this, &MainWindow::windowTitleChanged, watermark, [watermark, this]() {
        watermark->setGeometry(0, 0, this->width(), this->height());
    });

    watermark->lower();
    watermark->setAttribute(Qt::WA_TransparentForMouseEvents, true);
    watermark->setFocusPolicy(Qt::NoFocus);
    watermark->setGeometry(0, 0, width(), height());
    watermark->update();
}

void MainWindow::resizeEvent(QResizeEvent *event)
{
    QMainWindow::resizeEvent(event);
    WatermarkWidget *watermark = findChild<WatermarkWidget*>();
    if (watermark) {
        watermark->setGeometry(0, 0, width(), height());
        watermark->update();
    }
}

void MainWindow::loadStyleSheet()
{
    QString styleSheet;

    QStringList stylePaths = {
        ":/styles/mainwindow.qss",
        ":/styles/widget.qss",
        ":/styles/kanban.qss",
        ":/styles/calendar.qss",
        ":/styles/dialog.qss",
        ":/styles/statistic.qss",

    };

    for (const QString &path : stylePaths) {
        QFile file(path);
        if (file.open(QFile::ReadOnly | QFile::Text)) {
            styleSheet += QLatin1String(file.readAll());
            styleSheet += "\n";
            file.close();
        } else {
            qDebug() << "样式加载失败：" << path;
        }
    }

    if (!styleSheet.isEmpty()) {
        qApp->setStyleSheet("");
        qApp->setStyleSheet(styleSheet);
        qDebug() << "样式表应用成功";
    } else {
        qDebug() << "样式表为空，使用默认样式";
    }
}

void MainWindow::onTrayIconActivated(QSystemTrayIcon::ActivationReason reason)
{
    if (reason == QSystemTrayIcon::DoubleClick) {
        showMainWindow();
    }
}

void MainWindow::showMainWindow()
{
    show();
    raise();
    activateWindow();
}

void MainWindow::quitApplication()
{
    qApp->quit();
}

void MainWindow::onCalendarShowInspirations(const QDate &date)
{
    QList<QVariantMap> inspirations = inspirationModel->getInspirationsByDate(date);
    if (inspirations.isEmpty()) return;

    QDialog dlg(this);
    dlg.setWindowTitle(QString("灵感 - %1").arg(date.toString("MM月dd日")));
    dlg.resize(350, 500);
    dlg.setWindowFlags(dlg.windowFlags() & ~Qt::WindowContextHelpButtonHint);

    QVBoxLayout *layout = new QVBoxLayout(&dlg);
    QListWidget *listWidget = new QListWidget(&dlg);
    listWidget->setAlternatingRowColors(true);
    listWidget->setStyleSheet("QListWidget { border: none; background-color: #2d2d2d; } "
                              "QListWidget::item { padding: 10px; border-bottom: 1px solid #3d3d3d; }");

    for (const QVariantMap &data : inspirations) {
        QString timeStr = data["created_at"].toDateTime().toString("HH:mm");
        QString content = data["content"].toString();
        QString tags = data["tags"].toString();

        QListWidgetItem *item = new QListWidgetItem();
        item->setText(QString("[%1] %2\n🏷️ %3").arg(timeStr, content, tags));
        listWidget->addItem(item);
    }
    layout->addWidget(listWidget);
    dlg.exec();
}

void MainWindow::onCalendarShowTasks(const QDate &date)
{
    QList<QVariantMap> allTasks = taskModel->getAllTasks(false);
    QList<QVariantMap> dayTasks;
    for(const auto &t : allTasks) {
        if(t["deadline"].toDateTime().date() == date) {
            dayTasks.append(t);
        }
    }

    if (dayTasks.isEmpty()) return;

    QDialog dlg(this);
    dlg.setWindowTitle(QString("任务 - %1").arg(date.toString("MM月dd日")));
    dlg.resize(500, 300);
    dlg.setWindowFlags(dlg.windowFlags() & ~Qt::WindowContextHelpButtonHint);

    QVBoxLayout *layout = new QVBoxLayout(&dlg);

    QTableWidget *table = new QTableWidget(&dlg);
    table->setColumnCount(3);
    table->setHorizontalHeaderLabels({"ID", "标题", "截止时间"});
    table->horizontalHeader()->setSectionResizeMode(1, QHeaderView::Stretch);
    table->verticalHeader()->hide();
    table->setSelectionBehavior(QAbstractItemView::SelectRows);
    table->setEditTriggers(QAbstractItemView::NoEditTriggers);
    table->setAlternatingRowColors(true);
    table->setRowCount(dayTasks.size());

    for(int i=0; i<dayTasks.size(); ++i) {
        const auto &t = dayTasks[i];
        table->setItem(i, 0, new QTableWidgetItem(QString::number(t["id"].toInt())));
        table->setItem(i, 1, new QTableWidgetItem(t["title"].toString()));
        table->setItem(i, 2, new QTableWidgetItem(t["deadline"].toDateTime().toString("HH:mm")));
    }

    layout->addWidget(table);
    dlg.exec();
}
</file>

<file path="TaskManagementSystem.pro">
QT       += core gui sql printsupport
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17

# You can make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
    main.cpp \
    mainwindow.cpp \

HEADERS += \
    mainwindow.h \

#数据库模块
SOURCES += \
    database/database.cpp\

HEADERS += \
    database/database.h\

#模型模块
SOURCES += \
    models/taskmodel.cpp \
    models/inspirationmodel.cpp \
    models/taskfiltermodel.cpp \
    models/taskitem.cpp \
    models/statisticmodel.cpp

HEADERS += \
    models/taskmodel.h \
    models/inspirationmodel.h \
    models/taskfiltermodel.h \
    models/taskitem.h\
    models/statisticmodel.h

#视图模块
SOURCES += \
    views/kanbanview.cpp \
    views/calenderview.cpp \
    views/tasktableview.cpp \
    views/inspirationview.cpp\
    views/statisticview.cpp\

HEADERS += \
    views/kanbanview.h \
    views/calenderview.h \
    views/tasktableview.h \
    views/inspirationview.h\
    views/statisticview.h\

#对话框模块
SOURCES += \
    dialogs/taskdialog.cpp\
    dialogs/recyclebindialog.cpp\
    dialogs/inspirationdialog.cpp \
    dialogs/inspirationrecyclebindialog.cpp \
    dialogs/tagmanagerdialog.cpp \
    dialogs/inspirationtagsearchdialog.cpp\

HEADERS += \
    dialogs/taskdialog.h \
    dialogs/recyclebindialog.h\
    dialogs/inspirationdialog.h \
    dialogs/inspirationrecyclebindialog.h \
    dialogs/tagmanagerdialog.h \
    dialogs/inspirationtagsearchdialog.h\

FORMS += \
    dialogs/inspirationdialog.ui \
    dialogs/recyclebindialog.ui \
    dialogs/taskdialog.ui \
    dialogs/tagmanagerdialog.ui \

#控件模块
SOURCES += \
    widgets/watermarkwidget.cpp \
    widgets/tagwidget.cpp \
    widgets/prioritywidget.cpp \
    widgets/statuswidget.cpp \
    widgets/comboboxdelegate.cpp\
    widgets/simplechartwidget.cpp \

HEADERS += \
    widgets/watermarkwidget.h \
    widgets/tagwidget.h \
    widgets/prioritywidget.h \
    widgets/statuswidget.h \
    widgets/comboboxdelegate.h\
    widgets/simplechartwidget.h \

#工具模块
SOURCES += \
    utils/exporter.cpp \

HEADERS += \
   utils/exporter.h \

# 包含路径
INCLUDEPATH += \
    $$PWD/database \
    $$PWD/widgets \
    $$PWD/models \
    $$PWD/dialogs \
    $$PWD/views \
    $$PWD/utils\

# Default rules for deployment.
CODECFORTR = UTF-8
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

RESOURCES += \
    resources/resources.qrc \
</file>

</files>
